<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2019/04/15/Ashmem%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%80%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/04/15/Ashmem%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%80%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Ashmem匿名共享内存一——驱动程序"><a href="#Ashmem匿名共享内存一——驱动程序" class="headerlink" title="Ashmem匿名共享内存一——驱动程序"></a>Ashmem匿名共享内存一——驱动程序</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Ashmem，全称Anonymous  Shared Memory。匿名共享内存。</p><p>Ashmem匿名共享内存是Android系统实现的一种内存共享机制，用于IPC。与传统的Linux内存共享一样，Ashmem也是基于tmpfs实现的，不过Ashmem做了更为细致的内存管理，将整块共享内存切割，可动态回收，动态分配。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="ashmem-area"><a href="#ashmem-area" class="headerlink" title="ashmem_area"></a>ashmem_area</h4><p>用来描述一块共享内存。</p><ul><li><p>name：共享内存的名称。每一个块共享内存的名称都以dev/ashmem开头，如果没有指定名称，则名字就是dev/ashmem。</p></li><li><p>unpinned_list：描述一个解锁内存块列表。ashmem将整个共享内存分为多个小内存块，小内存块有两种状态，一种是锁定，即正在使用，不可回收；一种是解锁，解锁状态下的小内存块可以被回收。这个列表下的地址块互不相交，且按地址值从大到小排列。</p></li><li><p>file：指向临时文件系统tmpfs中的一个文件。</p></li><li><p>size：描述临时文件的大小。这个大小也就是匿名共享内存的大小。</p><blockquote><p>tmpfs：Linux提供的一种临时文件系统，其中的文件存在于内存中，不在硬盘上，也会挂载在文件系统中，不过断电即消失。可以用df命令查看。</p></blockquote></li><li><p>prot_mask：访问保护位。默认是exec|read|write。</p></li></ul><h4 id="ashmem-range"><a href="#ashmem-range" class="headerlink" title="ashmem_range"></a>ashmem_range</h4><p>用来描述一小块解锁内存块。</p><ul><li>unpinned：用于链入宿主共享内存的unpinned列表中。</li><li>lru：用于链入全局LRU链表ashmem_lru_list中，这个链表会在回收的时候用到。</li><li>pgstart/pgend：描述这一小块内存的开始和结束地址，单位是页。</li><li>purged：描述是否已经被回收。</li></ul><h4 id="ashmem-pin"><a href="#ashmem-pin" class="headerlink" title="ashmem_pin"></a>ashmem_pin</h4><p>作为IO控制命令ASHMEM_PIN和ASHMEM_UNPIN的参数，也即解锁和锁定时的参数。成员变量描述了起始地址和长度。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>驱动程序以misc设备文件的形式存在文件系统中，而每块共享内存则以tmpfs的形式存在文件系统中。</p><ul><li><p>创建两个slab缓冲区分配器，分别用来分配ashmem_area和ashmem_range。</p><blockquote><p>slab：缓冲区分配器。虚拟内存的内存分配是以页为单位，但有些小对象所需的内存空间比页大小要小得多，为其分配一整个页是效率低下的。slab分配器持有以页为单位的内存空间，而通过它可以将页再次分割，分配给小对象。</p></blockquote></li><li><p>调用misc_register注册一个匿名共享内存设备。ashmem被当做一个misc设备，以设备文件/dev/ashmem的形式放在文件系统中。应用程序通过它来访问Ashmem驱动程序。</p><blockquote><p>misc：意为杂乱的设备。Linux中专门用来管理特殊设备或者不知如何分类的设备，这些设备公用一个主设备号，以次设备号区分。</p></blockquote><p>ashmem_misc结构体正是ashmem设备文件在内存中的表现形式，其指定了设备文件名字、设备文件操作表（包含打开、关闭、映射、IO控制）。</p></li><li><p>向操作系统内存管理机制注册一个内存回收函数ashmem_shrinker。当系统内存不足时会调用这个函数，这会回收处于解锁状态的小内存块。</p></li></ul><h3 id="设备文件打开"><a href="#设备文件打开" class="headerlink" title="设备文件打开"></a>设备文件打开</h3><p>根据ashmem_misc中的操作表的指定，对设备文件的操作最终都会映射到ashmem.c中实现的各个函数。打开对应了ashmem_open。用户进程调用的是open，返回一个file，而ashmem_open中的参数file就是这个返回值。</p><ul><li>从slab缓冲区中分配一个ashmem_area结构体。做unpinned_list、名称（/dev/ashmem/<name>）、访问保护位的初始化。然后将其赋给file的private_data。</name></li></ul><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>当应用程序调用mmap将<strong>设备文件/dev/ashmem</strong>映射到地址空间时，Ashmem会创建一个临时文件。</p><ul><li>根据文件操作表的映射关系，mmap会被映射到ashmem_mmap，传进来的参数是打开时返回的file，和一个描述内存的结构体vma。</li><li>首先从file中获取ashmem_area。并做大小、访问标记位的判断。</li><li>创建临时文件。调用shmem_file_setup在临时文件tmpfs中创建一个临时文件，打开的文件保存在ashmem_area的成员变量file中。</li><li>将vma的映射文件设置为刚刚创建出来的临时文件，设置其内存操作表，主要改变其缺页方法fault为shmem_fault。其逻辑为：缺页时，先查页面缓冲区，如果有，则映射到缺页的虚拟地址；如果没有到换出设备中查，查到了添入缓冲区；如果再没有，分配新的物理页面，添入缓冲区。通过这种方式，则使用同一个file结构体，就是同一个页面缓冲区，可以映射到不同的vma中，实现了共享内存。</li></ul><h3 id="锁定和解锁"><a href="#锁定和解锁" class="headerlink" title="锁定和解锁"></a>锁定和解锁</h3><p>锁定和解锁主要是通过IO控制命令ASHMEM_PIN和ASHMEM_UNPIN来实现解锁。最终映射到ashmem_pin和ashmem_unpin。</p><ul><li>解锁：宿主共享内存的unpinned_list，按地址从大到小排列，而且互不相交，所以在解锁的时候，要查询顺序，判断是否相交，如果相交要合并；以此得出pgstart和pgend，然后通过slab分配一个ashmem_range结构体。再添入宿主列表unpinned_list和全局列表ashmem_lru_list中。</li><li>锁定：从unpinned_list和ashmem_lru_list中删除。</li></ul><h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p>回收函数ashmem_shrink在驱动程序初始化时就注册好了，当操作系统内存不足时，会调用这个函数，回收。回收的对象就是全局列表ashmem_lru_list中的解锁内存块。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Android系统提供Ashmem匿名共享内存机制，提供驱动程序，驱动程序以misc设备文件的形式存在系统中。命名为/dev/ashmem。</li><li>用户进程通过文件操作/dev/ashmem设备文件，访问Ashmem驱动程序，如打开、关闭、映射等等。</li><li>每块匿名共享内存对应一个临时文件，临时文件基于tmpfs实现，文件则相当于内存空间，其具有页面缓冲区等等内存结构。多个应用进程访问时，使用的是同一个页面缓冲区，以此实现了内存共享。</li><li>匿名共享内存对自己做了切割，将空闲的内存区域描述出来，注册给操作系统，当操作系统内存不足时，会回收这部分内存。</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/04/15/Ashmem%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BA%8C%E2%80%94%E2%80%94Runtime%E3%80%81Native%E3%80%81Framework/"/>
      <url>/2019/04/15/Ashmem%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BA%8C%E2%80%94%E2%80%94Runtime%E3%80%81Native%E3%80%81Framework/</url>
      
        <content type="html"><![CDATA[<h1 id="Ashmem匿名共享内存二——Runtime、Native、Framework"><a href="#Ashmem匿名共享内存二——Runtime、Native、Framework" class="headerlink" title="Ashmem匿名共享内存二——Runtime、Native、Framework"></a>Ashmem匿名共享内存二——Runtime、Native、Framework</h1><h2 id="Runtime中的cutils"><a href="#Runtime中的cutils" class="headerlink" title="Runtime中的cutils"></a>Runtime中的cutils</h2><p>提供了五个C接口来访问驱动程序。分别是<code>ashmem_create_region</code>创建、<code>ashmem_pin_region</code>锁定、<code>ashmem_unpin_region</code>解锁、<code>ashmem_set_prot_region</code>设置保护位、<code>ashmem_get_size_region</code>设置大小。</p><blockquote><p>region：区域</p></blockquote><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><ul><li>调用文件访问系统调用open，打开设备文件/dev/ashmem。会调用ashmem_open，创建一个ashmem_area结构体，返回一个文件描述符fd。</li><li>通过IO控制命令，为fd对应的匿名共享内存设置名字。</li><li>通过IO控制命令，给fd对应的匿名共享内存设置大小。</li><li>返回fd。</li></ul><h3 id="pin-unpin"><a href="#pin-unpin" class="headerlink" title="pin/unpin"></a>pin/unpin</h3><p>通过IO控制命令，锁定或解锁一小块内存空间，传递的参数是fd、ashmem_pin。</p><h3 id="set-prot"><a href="#set-prot" class="headerlink" title="set prot"></a>set prot</h3><p>通过IO控制命令，设置访问保护位。</p><p>###　get size</p><p>通过IO控制命令，获取匿名共享内存的大小。</p><h2 id="Native层C-接口"><a href="#Native层C-接口" class="headerlink" title="Native层C++接口"></a>Native层C++接口</h2><p>主要提供两个类，MemoryHeapBase和MemoryBase。</p><p>MemoryHeapBase是整块内存的共享，MemoryBase是共享部分内存。</p><p>这两个类都代表的是Service组件，其实就是一套写好的Binder。</p><h3 id="MemoryHeapBase"><a href="#MemoryHeapBase" class="headerlink" title="MemoryHeapBase"></a>MemoryHeapBase</h3><h4 id="IMemoryHeap"><a href="#IMemoryHeap" class="headerlink" title="IMemoryHeap"></a>IMemoryHeap</h4><p>IMemoryHeap类定义了接口，主要有四个函数：<code>getHeapID</code>获取文件描述符、<code>getBase</code>获取映射地址、<code>getSize</code>获取大小、<code>getFlags</code>获取保护位。</p><p>在Binder通讯中，Client端和Server端用的是同一个接口。</p><h4 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h4><p>通过Binder进行通讯，也就是Binder本地对象。</p><h5 id="BnMemoryHeap"><a href="#BnMemoryHeap" class="headerlink" title="BnMemoryHeap"></a>BnMemoryHeap</h5><p>只有onTransact，做中转。转到MemroyHeapBase。</p><h5 id="MemoryHeapBase-1"><a href="#MemoryHeapBase-1" class="headerlink" title="MemoryHeapBase"></a>MemoryHeapBase</h5><p>实现了IMemoryHeap接口。本身成员变量有：mFD文件描述符、mSize大小、mBase映射地址、mFlags访问保护位。</p><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><ul><li>调用ashmem_create_region，创建匿名共享内存，返回文件描述符，也就是mFD。这里会传入名字、大小、访问保护位。</li><li>mapfd，将内存块映射到本进程的地址空间。这里会调用到ashmem_mmap，会创建一个临时文件，即代表匿名共享内存。返回的值是映射的地址mBase。</li></ul><h6 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h6><p>就是返回成员变量</p><h4 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h4><h5 id="BpMemroyHeap"><a href="#BpMemroyHeap" class="headerlink" title="BpMemroyHeap"></a>BpMemroyHeap</h5><p>实现了IMemoryHeap。当Client进程第一次访问这个代理对象时，才会请求Server端返回匿名共享内存的信息。这个类在构造函数中只是赋初值，请求都是在接口实现中做的。</p><h6 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h6><ul><li>获取代理对象。Binder库为Client端维护了一个缓存，如果多个代理应用同个服务，返回的是同一个代理对象。如果代理对象已经存在，则返回，如果不存在，则创建返回。这个代理对象只记录了信息，并没有具体的实现。</li><li>请求。以代理对象的InterfaceDescriptor，通过Binder驱动，发送给服务端的对象，返回整个共享内存的信息，保存在本地。</li></ul><h6 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h6><ul><li>请求得到的共享内存的信息，调用mmap映射到本进程的空间。</li></ul><h6 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h6><ul><li>请求得到的共享内存的信息中有mBase，即一个映射地址，通过该地址则可以访问。</li></ul><h3 id="MemoryBase"><a href="#MemoryBase" class="headerlink" title="MemoryBase"></a>MemoryBase</h3><p>就是基于MemeoryHeapBase，加了偏移量和长度。其内部持有一个MemoryHeapBase实例，而其本身描述的就是这片内存的一小部分，以偏移量和长度表示。</p><h4 id="Server端-1"><a href="#Server端-1" class="headerlink" title="Server端"></a>Server端</h4><h5 id="IMemory"><a href="#IMemory" class="headerlink" title="IMemory"></a>IMemory</h5><p>定义了MemoryBase的服务接口，有四个接口函数<code>getMemory</code>获取内部的MemoryHeapBase、<code>pointer</code>获取MemoryBase描述的一小段内存、<code>size</code>大小、<code>offset</code>偏移量。</p><ul><li>pointer：获取内部的mHeap，然后加上偏移量返回，则可以得到那部分内存。</li></ul><h5 id="MemoryBase-1"><a href="#MemoryBase-1" class="headerlink" title="MemoryBase"></a>MemoryBase</h5><ul><li>getMemory：设置好offset和size，返回heap。</li></ul><h4 id="Client端-1"><a href="#Client端-1" class="headerlink" title="Client端"></a>Client端</h4><h5 id="BpMemroy"><a href="#BpMemroy" class="headerlink" title="BpMemroy"></a>BpMemroy</h5><p>通过Binder和Server端通讯，可以获取mHeap和偏移量。则这个地址可以访问。</p><h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p>Android对Ashmem共享内存提供的Java接口主要有一个类，即MemoryFile。</p><h3 id="MemoryFile"><a href="#MemoryFile" class="headerlink" title="MemoryFile"></a>MemoryFile</h3><p>封装了文件描述符、地址、保护位等等。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>有两种，一个是传入名称和长度，创建匿名共享内存，做映射。另一种是传入文件描述符，直接做映射。</p><p>一般情况下，Server端会用第一个构造函数；Client会用第二个构造函数。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>其他所有方法，包括read、write、getFileDescripter等等，都是调用了JNI，在JNI中使用cutils库提供的接口。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>MemoryFile的通讯，也即其内部的fd的传递，还是通过Binder，当Client端请求Server端的时候，Server端返回一个fd，Client端会使用第二个构造函数，创建、映射，所以一切的访问就是通过共享内存了。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>文件描述符都是通过Binder传递的，Server负责创建匿名共享内存、创建文件、完成映射，然后提供Binder服务，供Client获取文件描述符。Client获取文件描述符之后，再进行映射。接下来就可以通过映射出来的地址值访问了。</p></li><li><p>文件描述符只对本进程有效，但文件结构体只会有一个，多个文件描述符可以指向同一个文件结构体，文件结构体才真正代表着文件。所以Binder并不能直接传递文件描述符，而是在Client生成一个等价的文件描述符。</p><p>在传递文件描述符时，给Binder的协议是TYPE_FD，则Binder驱动在获取到Server端的文件描述符时，会先查到其对应的文件结构体，然后再查询目标进程中还没有使用的文件描述符，再将文件描述符和文件结构体关联，然后返回给Client端。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>2018年下半学期学期总结</title>
      <link href="/2019/03/12/2018%E4%B8%8B%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/12/2018%E4%B8%8B%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="2018年下学期学期总结"><a href="#2018年下学期学期总结" class="headerlink" title="2018年下学期学期总结"></a>2018年下学期学期总结</h1><p><strong>2018，很幸福的一年</strong></p><p>​    感觉过暑假、回学校，似乎还是不久前的事情，学期就要结束了。回家，带着满满的收获，期待着回家。</p><p>​    这个学期对我来说是突破的一个学期，从一个计算机领域的小新人，到迈过一道门槛、突破一个瓶颈，成为这个领域的一个小学生。是时候对这个学期做个总结了。</p><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>——<strong>放弃读研想法，决定毕业工作</strong></p><p>​    很开心在学期初做了这个决定，让我这个学期过得很有方向。其实也想了很久，争取读研对现在的我来说，性价比太低、意义不够、风险太大，衔两头顾两边不是我的风格，这个选择也是必然的吧。</p><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><p>——<strong>看了不少，收获不少，细节有待提升</strong></p><p>​    我看书总是比较快，我可能更喜欢多刷而不是仔细，但是这个习惯也导致知识比较容易遗忘，以后还要改进。整理一下这学期主要看的书：</p><ul><li><p>深入理解Java虚拟机：突然想起来这个书还有一两章没看完，这本书算是能让人更深入地了解JAVA究竟是什么样地。</p></li><li><p>Android系统源代码情景分析：看了可能有小一个月。特别感谢这本书，带我突破看源码的瓶颈，从没法看到能自己理逻辑。虽然讲的是挺老的版本，但其实源码的内容改的很少，整体逻辑是很少变得。这本书有些地方看了几次了，还会再看的。</p></li><li><p>C++ Primer Plus：为了看上面那本书，补C++知识，只求能看懂代码，花了一个星期撸了一遍，写是不存在的，看是基本能看懂了。</p></li><li><p>Android进阶解密：讲了热修复和插件化技术，对这方面我一直是存有好奇心的，不得机会了解，后来刘望舒这本书一出来，看到有讲这部分就买了。感觉好神奇，各种手段欺骗系统哈哈哈。这本书还讲了如Activity启动的原理等等，不过有些地方省略了，可能会对新手引起误解。</p></li><li><p>Linux内核设计与实现：了解Linux内核，强推此书。爽。之前翻阅过很多操作系统的书，要不就很晦涩，长篇大论，要不就皮毛，不爽。这本书是面向内核开发者的，讲原理，讲怎么用，深度对我个人来说觉得恰到好处。这本书看得比较细，虽然还是有很多细节忘了，但是对理解内核真的会深一步。</p></li></ul><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>——<strong>继续努力</strong></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>​    源码这块学期初花了好多时间在看一些常见的流程，包括：</p><ul><li>Activity启动</li><li>消息处理机制</li><li>Zygote、System进程启动</li><li>AMS等常见服务的启动</li></ul><p>​    这几个是比较认真看完了的，边看书，边看AOSP，书一般都比较老，自己一直比较好奇最新版本的原理，所以看了书，API28的我也会有看一遍。也写了写博客，遗憾的是只有Zygote、System那部分写完了，其余三个写了一半。</p><p>​    还有几个看一半的：</p><ul><li>Service、Fragment的生命周期</li><li>LayoutInflater</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>​    主要是跟着Linux内核设计与实现那本书看的，那时候觉得很爽，所以也写了挺多博客，发了两篇（IO、Pipe vs eventfd），两篇写完了还没校对更改（VFS、并发），几篇还想写。感觉这部分有很大的空间可以挖掘。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>架构：用了Jetpack撸码，一直感觉架构还能改进，于是有一个星期一直在看github上各大Android项目，学习别人怎么写，学到了很多骚操作。</li><li>Android VM</li><li>ANR</li><li>HashMap</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>——<strong>感恩</strong></p><p>​    手头有一个D工头的项目，感觉有个项目写挺幸福的，很多想法可以在项目上面实践。</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>——<strong>尽力而为，休养至上</strong></p><p>​    这个寒假吧，心里想做的事好多，但执行力能有多高就不清楚了。这个寒假最重要的事情还是好好休养，陪陪家人，以后时间会越来越少。</p><p>​    to-do-list，按优先级排序：</p><ul><li>Linux From Scratch：yx前些天找的那个。很感兴趣。如果有搞头，能搞的话，会花比较多的时间在这个上面。</li><li>项目继续做。</li><li>操作系统：跟着清华大学那个网课学一学，做实验。</li><li>性能优化：找了一些书，想了解一下这方面的东西。</li><li>博客：to-write-list里面有好多，尽可能把之前学的总结一下，写写出来。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>——<strong>再见 and 你好</strong></p><p>​    过得挺好的，感谢生活，感谢身边人的关心。    </p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 2018 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/03/12/Android%20Studio%20Gradle%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/03/12/Android%20Studio%20Gradle%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Studio-Gradle代理设置"><a href="#Android-Studio-Gradle代理设置" class="headerlink" title="Android Studio Gradle代理设置"></a>Android Studio Gradle代理设置</h1><p>代理一般有两种，一种是socks代理，一种是http代理，gradle针对这两种代理的设置方式不同。</p><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>编辑gradle.properties文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#systemProp.socks.proxyHost=127.0.0.1</span></span><br><span class="line"><span class="comment">#systemProp.socks.proxyPort=1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#systemProp.https.proxyHost=127.0.0.1</span></span><br><span class="line"><span class="comment">#systemProp.https.proxyPort=1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#systemProp.https.proxyHost=socks5://127.0.0.1</span></span><br><span class="line"><span class="comment">#systemProp.https.proxyPort=1080</span></span><br></pre></td></tr></table></figure><h3 id="Socks"><a href="#Socks" class="headerlink" title="Socks"></a>Socks</h3><p>编辑gradle.properties文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080</span><br></pre></td></tr></table></figure><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>个人第一次新建kotlin项目的时候，下载kotlin-compiler没挂代理真的不行，但是之后正常情况下打开，挂了代理真的不行！！有毒。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>我的Linux安装之旅（二）——Arch安装</title>
      <link href="/2019/01/25/%E6%88%91%E7%9A%84Linux%E5%AE%89%E8%A3%85%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Arch%E5%AE%89%E8%A3%85/"/>
      <url>/2019/01/25/%E6%88%91%E7%9A%84Linux%E5%AE%89%E8%A3%85%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Arch%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="我的Linux安装之旅（二）——Arch安装"><a href="#我的Linux安装之旅（二）——Arch安装" class="headerlink" title="我的Linux安装之旅（二）——Arch安装"></a>我的Linux安装之旅（二）——Arch安装</h1><p>这里还是要特别感谢<a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">wd老哥的Arch安装教程</a>。</p><p>And，本文我只按照自己的安装路径写，具体其他问题，可以参考上面的安装教程</p><h3 id="启动盘制作"><a href="#启动盘制作" class="headerlink" title="启动盘制作"></a>启动盘制作</h3><p>在<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">ArchLinux官网</a>上下载<code>archlinux-**-x86_64.iso</code>这个文件，然后写入事先准备好的U盘。Linux下可以用WoeUSB，Windows下可以用Rufus。</p><h3 id="进入U盘下的Linux"><a href="#进入U盘下的Linux" class="headerlink" title="进入U盘下的Linux"></a>进入U盘下的Linux</h3><p>首先进入BIOS下设置好启动顺序，把USB调到第一位。后进入U盘中写入的系统，等待加载完毕。</p><h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><ul><li><p>有线网：如果路由器支持DHCP的话，可以插上网线后执行<code>dhcpcd</code>命令</p></li><li><p>无线网：最坑的地方来了，但这里还问题不大。执行：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p>看看能不能连上，如果可以，完美。如果不可以，若是联想笔记本，可以借鉴我。</p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill unblock all</span><br></pre></td></tr></table></figure><p>如果问题解决，ok。若还是不行，继续执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill list</span><br></pre></td></tr></table></figure><p>看看是否有模块<code>XX</code>(如联想有可能是<code>ideapad_laptop</code>)排在<code>Wireless LAN</code>前面，若是有，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe -r XX //按实际情况替换</span><br></pre></td></tr></table></figure><p>如果没有问题，重新尝试连接。</p><p><strong>连接后可以执行命令测试</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure><h3 id="分区工作"><a href="#分区工作" class="headerlink" title="分区工作"></a>分区工作</h3><p>首先执行命令查看分区情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>我们的目的是准备好一个容量大的挂载根目录<code>/</code>，准备一个500M到1G的挂载<code>boot</code>分区，也就是EFI分区。</p><p>Linux中对硬盘的表示是<code>/dev/sd?</code>或者<code>/dev/nvmen?</code>，而这个名字之后，再带p？的，就是这个磁盘第？分区。</p><h5 id="创建引导分区"><a href="#创建引导分区" class="headerlink" title="创建引导分区"></a>创建引导分区</h5><p><strong>引导分区不用和windows一样，windows10默认下的EFI引导分区才100M，我们自己建一个新分区。</strong></p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/nvmen0</span><br></pre></td></tr></table></figure><ul><li><p>输入m可以查看命令帮助。</p></li><li><p>如果是一个全新的硬盘，注意按<code>g</code>创建分区表。</p></li><li><code>n</code>创建分区，<code>t</code>更改分区类型，<code>l</code>可以查看支持的类型，根据类型输入，更改该分区类型为<code>EFI</code></li><li><code>w</code>别忘了，生效。</li><li>格式化<code>mkfs.fat -F32 /dev/nvmen?p?</code>，<code>nvmen?p?</code>是要作为引导分区的分区。</li></ul><h5 id="创建根目录"><a href="#创建根目录" class="headerlink" title="创建根目录"></a>创建根目录</h5><p>与创建引导分区大致一样，不一样的是不用更改类型，并且格式化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/nvmen?p?</span><br></pre></td></tr></table></figure><h5 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h5><p>这个每次从U盘引导进来的，都要做一次：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nvmen?p? /mnt</span><br><span class="line">mkdir /mnt/boot</span><br><span class="line">mount /dev/nvmen?p? /mnt/boot</span><br></pre></td></tr></table></figure><h3 id="换镜像源"><a href="#换镜像源" class="headerlink" title="换镜像源"></a>换镜像源</h3><p>编辑<code>/etc/pacman.d/mirrorlist</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>更换一个速度快的国内源到第一行，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server=http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><h3 id="安装基本包"><a href="#安装基本包" class="headerlink" title="安装基本包"></a>安装基本包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel</span><br></pre></td></tr></table></figure><p>等待安装完成</p><h3 id="配置自动挂载"><a href="#配置自动挂载" class="headerlink" title="配置自动挂载"></a>配置自动挂载</h3><p>这一步很重要，利用genfstab帮助每次启动时进行自动挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -L /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>执行完检查一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>结果看看是不是达到目的。</p><p>同时有个坑，就是如果改动了分区挂载点，比如改动了<code>boot</code>分区，就要重新回来这一步，把原来的结果删除掉，重新执行生成自动挂载配置。一般如果没有执行的话，进入硬盘引导出来会报错<code>emergency mode</code>相关。</p><h3 id="操纵权改变"><a href="#操纵权改变" class="headerlink" title="操纵权改变"></a>操纵权改变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localltime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S vim dialog wps_supplicant ntfs-3g networkmanager</span><br></pre></td></tr></table></figure><h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>把<code>zh_CN.UTF-8 UTF-8</code> <code>zh_HK.UTF-8 UTF-8</code> <code>zh_TW.UTF-8 UTF-8`</code>en_US.UTF-8 UTF-8`四行取消注释。然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure><p>编辑<code>/etc/locale.conf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.conf</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><p>编辑<code>/etc/hostname</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><p>在文件第一行输入你的主机名，以后这个就是你在Linux下工作时，本计算机的名字。如<code>mycomputer</code></p><p>编辑<code>/etc/hosts</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost</span><br><span class="line">127.0.1.1mycomputer.localdomainmycomputer</span><br></pre></td></tr></table></figure><h3 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><h3 id="IntelCPU安装Intel-ucode"><a href="#IntelCPU安装Intel-ucode" class="headerlink" title="IntelCPU安装Intel-ucode"></a>IntelCPU安装Intel-ucode</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode</span><br></pre></td></tr></table></figure><h3 id="安装Bootloader"><a href="#安装Bootloader" class="headerlink" title="安装Bootloader"></a>安装Bootloader</h3><p>最流行的是<code>Grub2</code></p><h5 id="安装os-prober"><a href="#安装os-prober" class="headerlink" title="安装os-prober"></a>安装os-prober</h5><p>它是用来帮助<code>grub</code>检测硬盘中存在的其他系统，如双系统时的windows。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S os-prober</span><br></pre></td></tr></table></figure><h5 id="安装配置grub引导"><a href="#安装配置grub引导" class="headerlink" title="安装配置grub引导"></a>安装配置grub引导</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br></pre></td></tr></table></figure><p>部署<code>grub</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub</span><br></pre></td></tr></table></figure><p>生成配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>这一步大概率出错。</p><ul><li><p>如果是<code>lvmetad/lvm</code>相关错误，或者是<code>WARNING: Device /dev/*xxx* not initialized in udev database even after waiting 10000000 microseconds</code>等等，应该</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit //退出arch-chroot</span><br><span class="line">mkdir /mnt/hostlvm</span><br><span class="line">mount --bind /run/lvm /mnt/hostlvm</span><br><span class="line">arch-chroot /mnt</span><br><span class="line">ln -s /hostlvm /run/lvm</span><br></pre></td></tr></table></figure><p>  再执行生成配置的命令，一般可以成功。</p><p>  <strong>需要注意的是，这一段如果是重启，重新进入，很可能要再执行一次</strong></p></li><li><p>如果没有扫到Linux的镜像，要先执行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S linux</span><br></pre></td></tr></table></figure></li><li><p>如果没有扫到windows，可以忽略，等到不用U盘引导而是硬盘引导进入系统时，再执行一次生成配置。</p></li></ul><h5 id="安装后检查"><a href="#安装后检查" class="headerlink" title="安装后检查"></a>安装后检查</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>查查在文件中<code>menuentry</code>是不是有对应的系统引导信息。</p><h3 id="重启进入硬盘引导的系统"><a href="#重启进入硬盘引导的系统" class="headerlink" title="重启进入硬盘引导的系统"></a>重启进入硬盘引导的系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>如果grub部署问题不大，可以直接进入grub引导下的arch系统。</p><p>重启后记得，如果在U盘下没有部署其他系统的引导，重新执行一次grub生成配置的命令。</p><h3 id="创建交换文件"><a href="#创建交换文件" class="headerlink" title="创建交换文件"></a>创建交换文件</h3><p>交换文件是用于内存不足时缓存部分旧内容。</p><p>分配空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallocate -l 8G /swapfile</span><br></pre></td></tr></table></figure><p>大小看内存，足够大的情况下，可以4-8G。</p><p>更改权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /swapfile</span><br></pre></td></tr></table></figure><p>设置交换文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure><p>启用交换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure><p>设置交换文件分区的自动挂载，编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swapfile none swap defaults 0 0</span><br></pre></td></tr></table></figure><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p>在此之前都是<code>root</code>用户下，从此要创建新用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel username</span><br></pre></td></tr></table></figure><p><code>username</code>自行更改，就是用户名，<code>wheel</code>是组名，一般这么写就好了，不用改，后面会用到。</p><p>设置用户密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><h3 id="解决网络问题"><a href="#解决网络问题" class="headerlink" title="解决网络问题"></a>解决网络问题</h3><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p>如果无法连接，和上面相似，需要进行<code>rfkill unblcok all</code>的话，可以把它写成开机自动。如果还没有解决，仍然是<code>rfkill list</code>，如果有模块<code>XX</code>（这里使用我的情况<code>ideapad_laptop</code>），编辑<code>/etc/modprobe.d/ideapad_laptop.conf</code>：</p><p>在里面添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blacklist ideapad_laptop</span><br></pre></td></tr></table></figure><p>然后重启再试试。</p><p>如果还有问题，看看自己的无线网卡是不是realtek的，realtek无线网卡一生黑。</p><h3 id="配置sudo"><a href="#配置sudo" class="headerlink" title="配置sudo"></a>配置sudo</h3><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S sudo</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>找到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> %wheel ALL=(ALL)ALL</span></span><br></pre></td></tr></table></figure><p>去掉注释，然后重启系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="显卡驱动安装"><a href="#显卡驱动安装" class="headerlink" title="显卡驱动安装"></a>显卡驱动安装</h3><p>英特尔集显：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xf86-video-intel</span><br></pre></td></tr></table></figure><p>NVIDIA独显：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nvidia nvidia-utils lib32-nvidia-utils</span><br></pre></td></tr></table></figure><p><strong>独显安装完后，在桌面环境安装完之后，还要做一点配置，否则经常登录界面是黑屏</strong></p><h3 id="桌面环境Deepin"><a href="#桌面环境Deepin" class="headerlink" title="桌面环境Deepin"></a>桌面环境Deepin</h3><p>安装xorg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xorg</span><br></pre></td></tr></table></figure><p>安装deepin：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S deepin deepin-extra</span><br></pre></td></tr></table></figure><p>配置Deepin，编辑<code>/etc/lightdm/lightdm.conf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Seat:*]</span><br><span class="line">...</span><br><span class="line">greeter-session=lightdm-deepin-greeter</span><br></pre></td></tr></table></figure><h3 id="独显驱动完善"><a href="#独显驱动完善" class="headerlink" title="独显驱动完善"></a>独显驱动完善</h3><p>可以参考<a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus" target="_blank" rel="noopener">Archwiki对NVIDIA独显的配置文章</a>。</p><p>由于Deepin用Lightdm进行引导桌面启动，首先编辑<code>/etc/lightdm/display_setup.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">xrandr --setprovideroutputsource modesetting NVIDIA-0</span><br><span class="line">xrandr --auto</span><br></pre></td></tr></table></figure><p>给权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/lightdm/display_setup.sh</span><br></pre></td></tr></table></figure><p>编辑<code>/etc/lightdm/lightdm.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Seat:*]</span><br><span class="line">display-setup-script=/etc/lightdm/display_setup.sh</span><br></pre></td></tr></table></figure><p>启用lightdm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> lightdm</span><br></pre></td></tr></table></figure><p>如果用的是<code>SDDM</code>或者其他桌面管理，可以参考ArchWiki。</p><h3 id="网络问题完善"><a href="#网络问题完善" class="headerlink" title="网络问题完善"></a>网络问题完善</h3><p>桌面环境下用的是<code>NetworkManager</code>这个服务，一开始命令行用的是<code>netctl</code>，所以要做禁用和启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> netctl</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> NetworkManager</span><br></pre></td></tr></table></figure><h3 id="安装yay"><a href="#安装yay" class="headerlink" title="安装yay"></a>安装yay</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay.git</span><br><span class="line"><span class="built_in">cd</span> yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><h3 id="滚Arch"><a href="#滚Arch" class="headerlink" title="滚Arch"></a>滚Arch</h3><p>Arch不滚还有何乐趣？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Syu</span><br></pre></td></tr></table></figure><h3 id="墙墙"><a href="#墙墙" class="headerlink" title="墙墙"></a>墙墙</h3><p>个人觉得图形界面版的shadowsocks好用，不过这个萝卜青菜。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S shadowsocks-qt5</span><br></pre></td></tr></table></figure><p>之后打开<code>shadowsocks</code>，自己玩玩。</p><h3 id="Chrome代理"><a href="#Chrome代理" class="headerlink" title="Chrome代理"></a>Chrome代理</h3><p>先安装Chrome，可以用yay：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S google-chrome</span><br></pre></td></tr></table></figure><p>在代理下启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google-chrome-stable --proxy-server=<span class="string">"socks5://127.0.0.1:1080"</span></span><br></pre></td></tr></table></figure><p>这里的socks5有可能是http，这取决于shadowsocks里的设置。</p><p>然后安装<code>SwitchyOmega</code>这个插件。</p><h3 id="命令行代理"><a href="#命令行代理" class="headerlink" title="命令行代理"></a>命令行代理</h3><p>安装<code>proxychains-ng</code>，然后编辑<code>/etc/proxychains.conf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><p>这里的socks5也有可能是http，取决于shadowsocks里的设置。</p><h3 id="添加中国源"><a href="#添加中国源" class="headerlink" title="添加中国源"></a>添加中国源</h3><p>中国源ArchlinuxCN，很多中文软件如搜狗拼音，都在arch中国源中。编辑<code>/etc/pacman.conf</code>，在最后面加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Sy</span><br></pre></td></tr></table></figure><h3 id="中文字体"><a href="#中文字体" class="headerlink" title="中文字体"></a>中文字体</h3><p>刚刚安装完成的Arch中文是乱码的，可以参考<a href="https://wiki.archlinux.org/index.php/Fonts_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">ArchWiki中文字体</a>#%E4%B8%AD%E6%96%87%E5%AD%97)</p><p>安装自己喜欢的中文字体，然后更新字体缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-cache -vf</span><br></pre></td></tr></table></figure><p>这个字体是可以在图形界面里面设置的，也可以手动设置配置文件。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>安装<code>fcitx fcitx-im fcitx-configtoolfcitx-gtk2 fcitx-gtk3 fcitx-qt4 fcitx-qt5</code>，然后安装自己喜欢的输入法，如搜狗拼音<code>fcitx-sogoupinyin</code>。</p><p>然后启动fcitx-configtools，在里面按+号键，添加自己安装的输入法，就可以使用了。</p><h3 id="安装QQ、Tim、wechat"><a href="#安装QQ、Tim、wechat" class="headerlink" title="安装QQ、Tim、wechat"></a>安装QQ、Tim、wechat</h3><p>先启用multilib库，编辑<code>/etc/pacman.conf</code>，对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>这两行取消注释。然后执行<code>yay -Syy</code></p><p>安装Tim</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.qq.office</span><br></pre></td></tr></table></figure><p>qq</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.qq.im</span><br></pre></td></tr></table></figure><p>wechat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin-wechat</span><br></pre></td></tr></table></figure><h3 id="解决无法关机问题"><a href="#解决无法关机问题" class="headerlink" title="解决无法关机问题"></a>解决无法关机问题</h3><p>如果关机特别慢甚至无法关机，可以尝试编辑<code>/etc/systemd/system.conf</code>文件，将</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DefaultTimeoutStopSec=90s</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultTimeoutStopSec=10s</span><br></pre></td></tr></table></figure><h3 id="蓝牙安装"><a href="#蓝牙安装" class="headerlink" title="蓝牙安装"></a>蓝牙安装</h3><p>安装蓝牙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S bluez bluez-utils</span><br><span class="line">systemctl start bluetooth</span><br><span class="line">systemctl <span class="built_in">enable</span> bluetooth</span><br></pre></td></tr></table></figure><p>安装蓝牙音频</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S pulseaudio-bluetooth</span><br><span class="line">sudo vim /etc/pulse/system.pa</span><br></pre></td></tr></table></figure><p>配置蓝牙音频</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load-module module-bluetooth-policy</span><br><span class="line">load-module module-bluetooth-discover</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的Linux安装之旅（一）——扯淡</title>
      <link href="/2019/01/25/%E6%88%91%E7%9A%84Linux%E5%AE%89%E8%A3%85%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%89%AF%E6%B7%A1/"/>
      <url>/2019/01/25/%E6%88%91%E7%9A%84Linux%E5%AE%89%E8%A3%85%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%89%AF%E6%B7%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="我的Linux安装之旅（一）——扯淡"><a href="#我的Linux安装之旅（一）——扯淡" class="headerlink" title="我的Linux安装之旅（一）——扯淡"></a>我的Linux安装之旅（一）——扯淡</h1><p>​    说起我的Linux之旅，讲道理并不怎么愉快。。。四火对Linux很感兴趣，但在Linux安装使用这条路上踩了太多坑，甚至曾经对Linux产生了心里阴影了。</p><p>​    大一的时候总想试试，但限于知识水平有限，在安装时总会有很多愚蠢的做法，说起那时候甚至对最简单的概念，如挂载等，都没有理解其意义，可想而知会有很多愚蠢的做法。</p><p>​    大一暑假想要换电脑，那时候总在犹豫是否要换Mac，那时候我其实特别想换Mac，但又不甘于没有好好用过Linux，最终买了我现在在用的联想Y7000，然而就是这台电脑，让我痛苦地、错误地体会着Linux。</p><p>​    众所周知，Linux最难受的地方，在显卡和网卡，Y7000在这两块都碰到兼容性问题。。。真难过。而独显的问题还好解决，最难解决的是网卡（rtl8822be。嘤嘤嘤。Realtek网卡一生黑。</p><p>​    和很多人一样，刚开始我也选择了比较容易的ubuntu等发行版安装，但显卡和网卡的问题总是存在！！！甚至我的网卡问题，是偶然出现的，时灵时不灵，想好就好，不想好突然就挂。为了解决网络的问题，我把谷歌上所有关于rtl8822be网卡在Linux上的驱动问题的文章全都看了一遍，都没有解决。。。</p><p>​    从买了Y7000到大二上学期这一段时间，我好多次尝试装Linux，始终没有能完美解决问题。</p><p>​    到了近日，也就是大二这个寒假，我决定再来。因为有了一定的知识积累，在面对一些问题的时候，总不至于像以前那么懵逼，所以这我选择了装Arch。当然，最终我没有能够解决rtl8822be这个无线网卡的问题，我换了一个Intel的无线网卡，体验非常完美，开箱即用（realtek网卡一生黑）</p><p>​    想了想，还是要把安装过程中的一些问题记录下来，以便以后查阅。</p><p>​    这里特别感谢<a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">wd老哥的Arch安装教程</a>！！</p><p>​    PS：个人还想玩一玩Linux from scratch哈哈哈，玩好了也会记录下来的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>两种IPC方式 Pipe vs eventfd</title>
      <link href="/2018/11/05/Pipe_vs_eventfd/"/>
      <url>/2018/11/05/Pipe_vs_eventfd/</url>
      
        <content type="html"><![CDATA[<h1 id="两种IPC方式-Pipe-vs-eventfd"><a href="#两种IPC方式-Pipe-vs-eventfd" class="headerlink" title="两种IPC方式 Pipe vs eventfd"></a>两种IPC方式 Pipe vs eventfd</h1><p>四火想专门对比这两种IPC方式的原因是，这些天在看Android的消息处理机制，书上的源码用的是老版本的Android，使用的IPC是管道，但最新版本的AOSP中，消息处理机制使用的IPC方式已经改为eventfd了。好奇心激发我去了解了一下，有必要记录下来。</p><h2 id="pipe管道"><a href="#pipe管道" class="headerlink" title="pipe管道"></a>pipe管道</h2><p>管道是最原始最基本的IPC机制，用于在进程之间完成数据传递。管道的特点非常鲜明：管道的数据传输是单向的，只能一端写一端读，所以它也采用了两个文件描述符引用，一个表示读端一个表示写端。</p><p>对管道进行读写实质上是对内核空间中的一片区域进行读写，管道是由内核管理的一个缓冲区，相当于我们放入内存中的一张纸，但这张纸读和写是完全分开的，管道的一端连接一个进程的输入，另一端连接一个进程的输出。</p><p>管道分两种，一种是无名管道，这种管道一般是存在与父子进程或者兄弟进程之间，在Linux系统中可以根据特殊的系统调用，创建一条单向连接的管道，联通父子进程或兄弟进程。还有一种是命名管道，即将管道抽象为文件存放于文件系统之中，等待进程通过该文件与管道建立连接。</p><h2 id="eventfd"><a href="#eventfd" class="headerlink" title="eventfd"></a>eventfd</h2><p>eventfd是Linux系统后来才引入的另一种轻量级的IPC方式，不同进程可以通过eventfd机制建立起一个共享的计数器，这个计数器由内核负责维护，充当了信息的角色，与它关联的进程可以对其进行读写，从而起到进程间通讯的目的。</p><h4 id="提供的方法："><a href="#提供的方法：" class="headerlink" title="提供的方法："></a>提供的方法：</h4><ul><li><p>eventfd：创建一个eventfd，返回一个文件描述符，通过该文件描述符可对eventfd进行读写操作。</p></li><li><p>read:读取计数器中的值：</p><ul><li>计数器中的值大于0，非初始状态<ul><li>设置了EFD_SEMAPHORE标志，返回1，且计数器中的值减1，这个模式是为跨进程做递减标记等而设计及的。</li><li>没有设置EFD_SEMAPHORE标志，返回计数器中的值，计数器清零</li></ul></li><li>计数器中的值等于0，说明没有人写入值，初始状态默认为0<ul><li>设置了EFD_NOBLOCK标志，返回-1，不阻塞。</li><li>没有设置EFD_NOBLOCK标记，阻塞直到计数器中的值大于0</li></ul></li></ul></li><li>write：向计数器写值，写入的值会和原先计数器中的值累加<ul><li>写入的值和原先计数器中的值的和小于0xFFFFFFFFFFFFFFFE，写入成功</li><li>否则<ul><li>设置了EFD_NONBLOCK标志，返回-1</li><li>没有设置，阻塞直到read</li></ul></li></ul></li><li>close关闭</li></ul><h3 id="对比Pipe和eventfd"><a href="#对比Pipe和eventfd" class="headerlink" title="对比Pipe和eventfd"></a>对比Pipe和eventfd</h3><p>eventfd是Linux在后版本中才提出来的一种IPC通讯方式，它更加轻量级，也更加灵活，它避免了pipe必须一端读一端写这个弊端，而且只创建了一个文件描述符，pipe必须创建读写两个文件描述符。eventfd的性能要比pipe要更好。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>pipe和eventfd都有一个非常巧妙的设计，就是可以与select、poll、epoll配合使用，以达到监听数据传输的目的。</p><p>这里以eventfd做讲解，eventfd本身并没有提供监听的功能，也就是说，计数器的数据被改变时，引用这个eventfd的进程并不会收到通知。但Linux在推出eventfd机制的时候，就已经设计好其可以和select、poll、epoll配合使用。这三个系统调用可以用来监听某个文件描述符（常指向的是一个socket，但这里是eventfd的计数器）中的数据，它们使用的时候需要传入一个封装的文件描述符用来指定监听目标，而eventfd创建时所返回的文件描述符正好可以传进其中。</p><p>eventfd经常会和epoll一起出现，在Android消息处理机制中，监听是否有消息传入用的机制就是eventfd+epoll。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> IPC </tag>
            
            <tag> Android消息处理机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux I/O简记</title>
      <link href="/2018/11/05/Linux_IO%E7%AE%80%E8%AE%B0/"/>
      <url>/2018/11/05/Linux_IO%E7%AE%80%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-I-O简记"><a href="#Linux-I-O简记" class="headerlink" title="Linux I/O简记"></a>Linux I/O简记</h1><h2 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h2><p>Linux默认的IO操作都是缓存IO，数据从源出发，不会被直接传送到目的，而是要经过内核，通过这种方式保证了内核对IO操作的可控。内核为IO提供了一个数据缓冲区，数据从源出发，先被拷贝到内核的缓冲区中，然后才从缓冲区拷贝到目的进程的用户地址空间。</p><h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><p>Linux为IO提供了5种方案：</p><ol><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ol><h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="1. 阻塞IO"></a>1. 阻塞IO</h3><p>Linux中，socket默认都是阻塞IO，用户进程通过系统调用，向内核索要数据read，内核会进行数据准备（比如网络IO中等待数据到达）。这个数据准备过程需要事件，而阻塞IO的特点就是在数据准备的过程中，用户进程会被阻塞，直到内核准备好了数据，才返回结果给用户进程，使用户进程唤醒。</p><h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="2. 非阻塞IO"></a>2. 非阻塞IO</h3><p>用户进程发出read，如果内核还没有准备好，会返回error，用户进程不需要等待，但是它取不到数据的可能性很大，需要不断地发出read请求，直到内核准备好了数据。</p><h3 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3. IO多路复用"></a>3. IO多路复用</h3><p>IO多路复用常见于select、poll、epoll。多路IO顾名思义同时进行多个IO，它的意义在于同时与多个Socket进行IO，只要监听列表中有一个或者多个socket有数据到来，用户进程就会被唤醒，通知处理。下面分别讲讲select、poll和epoll</p><h4 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1 select"></a>3.1 select</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select函数的主要逻辑是，传入要监听的文件描述符，用户进程需要将这些文件描述符fds拷贝给内核，而且这里文件描述符的数量是有限的，一般是被宏定义为1024，然后内核对fds指向的socket进行监听，挨个进行poll逻辑，检查是不是有可读事件，如果一个都没有，用户进程陷入阻塞。如果有事件到来，内核就会唤醒用户进程，接下来用户进程需要对每个socket尝试读取。</p><p>所以select有很大的缺点</p><ol><li>fds集合的大小只能是1024以下，太小了</li><li>fds需要从用于空间拷贝到内核空间，太麻烦了。</li><li>只要有一个fds是有数据可读的，所有socket都要被遍历一次，太惨了。</li></ol><h4 id="3-2-poll"><a href="#3-2-poll" class="headerlink" title="3.2 poll"></a>3.2 poll</h4><p>poll其实有点傻，poll只解决了1024问题，就是把监听的文件大小变大了，但没有解决第2、3个问题，这就意味着，监听的文件数量可以很大，但每次只要有一个事件到来，就要遍历所有的socket，这就很尴尬了，一旦大并发，不言而喻。</p><h4 id="3-3-epoll"><a href="#3-3-epoll" class="headerlink" title="3.3 epoll"></a>3.3 epoll</h4><p>select的第一个缺点很好解决，解决第二、三个缺点比较棘手，epoll采用了两个思想，一是添加中间层封装简化处理，二是分散事件处理，将高频、低频、不同事件分开处理，提高处理精确度。</p><h5 id="3-3-1-分散处理优化拷贝消耗"><a href="#3-3-1-分散处理优化拷贝消耗" class="headerlink" title="3.3.1 分散处理优化拷贝消耗"></a>3.3.1 分散处理优化拷贝消耗</h5><p>epoll将高频调用的唤醒/等待与低频调用的添加/删除/修改fd分开。唤醒、通知回调处理、等待这块的逻辑，epoll采用了内存映射，将内核空间中存储要返回给用户空间的数据的这块空间，映射到用户空间中，这样就避免了多次的内存拷贝，用户空间能直接访问到返回的数据。添加删除修改监听事件的逻辑，则是被分开进行处理，减少冗余的内存占用。</p><h5 id="3-3-2-中间层实线按需遍历"><a href="#3-3-2-中间层实线按需遍历" class="headerlink" title="3.3.2 中间层实线按需遍历"></a>3.3.2 中间层实线按需遍历</h5><p>epoll添加了中间层用来精确处理有数据返回的fds，只将有数据的fds暴露给用户进程，这样就避免了用户进程每次都要遍历所有监听的socket，极大地减少了内存占用。在select/poll中，用户进程会睡眠在一个包含其监听的所有socket的集合上，每次这个集合中有准备好的socket，就会唤醒该用户进程。而在epoll中，用户进程则是睡眠在epoll提供的中间层上，中间层再引入一个wait_entry_sk，与每个监听的socket一一对应，然后睡眠在socket集合上，每当集合中有事件来临，则通知wait_entry_sk，将它对应的socket放入中间层提供的ready_list中，然后唤醒用户进程去处理ready_list。</p><h3 id="4-信号驱动IO"><a href="#4-信号驱动IO" class="headerlink" title="4. 信号驱动IO"></a>4. 信号驱动IO</h3><p>信号驱动IO是一种半阻塞的IO，在准备数据阶段不阻塞，用户进程发送read后，直接返回。而等到数据准备完成之后，内核给用户空间发信号，通知用户进程阻塞，然后再将数据从内核空间复制到用户空间，这个过程是阻塞的。这种IO方式用得比较少。</p><h3 id="5-异步IO"><a href="#5-异步IO" class="headerlink" title="5. 异步IO"></a>5. 异步IO</h3><p>异步IO在整个IO过程中均不阻塞，用户进程发起read操作之后，立即返回，而内核接收请求之后，进行数据准备，并且在数据准备完成之后，将数据复制到用户进程空间，整个过程均不阻塞用户进程，完成之后再发送信号通知用户进程读取数据。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> I/O </tag>
            
            <tag> 多路复用 </tag>
            
            <tag> poll、epoll、select </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Zygote、System进程启动</title>
      <link href="/2018/10/19/Zygote%E3%80%81System%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/10/19/Zygote%E3%80%81System%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Zygote、System进程启动"><a href="#Zygote、System进程启动" class="headerlink" title="Zygote、System进程启动"></a>Zygote、System进程启动</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    Zygote，翻译为中文是“受精卵”，它是Android系统中，所有Java进程的父进程，负责创建新进程。System进程，是Android系统中系统服务运行所在的进程，它负责创建、管理所有的系统服务，包括AMS、PackageManagerServer等等十分重要的服务，都运行在System进程中。</p><p>​    Zygote和System进程的生命周期伴随整个系统，在系统启动时就会启动这两个进程，而直到系统关闭，它们才会被杀死。</p><p>​    值得一提的是，在Android5.0之后，Zygote进程在系统中一共存在两个，这主要是为了适应新增加的64位app而设计的，它们两个的主要功能其实是一致的。</p><p>​    And，System进程其实也是Zygote进程的子进程，它们启动的顺序大概可以描述为，Linux系统的初始化进程<code>&lt;init&gt;</code>通过读取脚本，创建Zygote，Zygote创建完成之后，先启动了System进程，然后自己再等待其他创建请求。</p><p>​    本文以API28的源码为基础进行分析。</p><hr><h2 id="Zygote启动过程"><a href="#Zygote启动过程" class="headerlink" title="Zygote启动过程"></a>Zygote启动过程</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><ol><li>init进程加载脚本，启动app_process文件中的main函数</li></ol><ol start="2"><li>创建虚拟机实例，进入ZygoteInit类的main方法中</li></ol><ol start="3"><li>创建一个Socket</li></ol><ol start="4"><li>fork出System进程</li></ol><ol start="5"><li>自己进入死循环中，不断从第3步创建的Socket中获取是否有创建进程的请求，并进行处理。</li></ol><hr><h3 id="Step1-app-main-main"><a href="#Step1-app-main-main" class="headerlink" title="Step1: app_main.main"></a>Step1: app_main.main</h3><p><strong>frameworks/base/cmds/app_process/app_main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走这个方法的目的是解析启动脚本中传进来的参数并真正调用方法启动进程。</p><ol><li>创建一个AppRuntime对象，是AndroidRuntime的子类，它的定义就在app_main文件中。</li></ol><ol start="2"><li>做一些解析工作，解析从启动脚本传过来的参数，这里要启动的是zygote进程，所以zygote变量为true。</li></ol><ol start="3"><li>调用runtime的start方法，runtime就是第一步创建的AppRuntime对象，但是它没有重写start方法，start方法是在它的父类AndroidRuntime中的。注意：传入的参数是ZygoteInit类的全名以及要传给这个类的参数，以及最后一个判断启动的是否是zygote进程的bool值。</li></ol><hr><h3 id="Step2-AndroidRuntime-start"><a href="#Step2-AndroidRuntime-start" class="headerlink" title="Step2: AndroidRuntime.start"></a>Step2: AndroidRuntime.start</h3><p><strong>frameworks/base/core/jni/AndroidRuntime.cpp</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">  ...</span><br><span class="line">  strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>, <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">    ...</span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>走这个方法的目的是从c++的世界转入Java的世界。</p><ol><li>初始化JNI</li></ol><ol start="2"><li>创建并开启一个虚拟机实例</li></ol><ol start="3"><li>给这个虚拟机注册JNI方法</li></ol><ol start="4"><li>各种解析之后，调用<code>env-&gt;CallStaticVoidMethod</code>方法，从而调起Java的方法，传入的三个参数分别是要调用的Java类、要调用的方法、传给方法的参数，这里要调用的Java类正是从上一步传进来ZygoteInit类的全称解析出来的，而<code>startMeth</code>参数是main方法，所以这里调用起来的是ZygoteInit的main方法。</li></ol><pre><code>**宣布进入Java的世界！**</code></pre><hr><h3 id="Step3-ZygoteInit-main"><a href="#Step3-ZygoteInit-main" class="headerlink" title="Step3: ZygoteInit.main"></a>Step3: ZygoteInit.main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">    String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">    String abiList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">            startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">            enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">            abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">            socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">        <span class="comment">// child (system_server) process.</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建ZygoteServer，然后做各种标记位的判断，比如<code>startSystemServer</code>判断是否要启动System进程，这里为true。</li></ol><ol start="2"><li>调用<code>zygoteServer.registerServerSocketFromEnv</code> (详见Step3.1)，创建一个Server端Socket，用来等待AMS请求，以创建应用程序进程。但这时候只是创建，还没开始等待。</li></ol><ol start="3"><li><code>forkSystemServer</code> (详见Step3.2) 创建一个新的子进程，这个新的子进程就是System进程，这里讨论的是Zygote的创建，这个方法会返回null，具体原因见Step3.2</li></ol><ol start="4"><li>调用<code>runSelectLoop</code>方法，在这个方法中无限等待请求。</li></ol><h4 id="Step3-1-ZygoteServer-registerServerSocketFromEnv"><a href="#Step3-1-ZygoteServer-registerServerSocketFromEnv" class="headerlink" title="Step3.1: ZygoteServer.registerServerSocketFromEnv"></a>Step3.1: ZygoteServer.registerServerSocketFromEnv</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerServerSocketFromEnv</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fileDesc;</span><br><span class="line">        ...</span><br><span class="line">        String env = System.getenv(fullSocketName);</span><br><span class="line">        fileDesc = Integer.parseInt(env);</span><br><span class="line">        ...</span><br><span class="line">        FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        ...</span><br><span class="line">        mServerSocket = <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Step3的第2步，创建并注册Socket。</p><p>通过socket的名字创建文件操作符，然后再通过文件操作符创建一个socket，其实这个socket在操作系统中的表现形式就是一个文件（这是关于Linux系统的知识，这里不详述）这个socket就存在成员变量<code>mServerSocket</code>中。</p><h4 id="Step3-2-ZygoteInit-forkSystemServer"><a href="#Step3-2-ZygoteInit-forkSystemServer" class="headerlink" title="Step3.2: ZygoteInit.forkSystemServer"></a>Step3.2: ZygoteInit.forkSystemServer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        String args[] = &#123;</span><br><span class="line">            <span class="string">"--setuid=1000"</span>,</span><br><span class="line">            <span class="string">"--setgid=1000"</span>,</span><br><span class="line">            <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010"</span>,</span><br><span class="line">            <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">            <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">            <span class="string">"--runtime-args"</span>,</span><br><span class="line">            <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">            <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.runtimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">                    </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Step3的第2步，它的目的是创建System进程</p><ol><li>首先是置顶了一些参数，这些参数主要是针对即将创建的子进程，即System进程的，可以看到这里为System进程设定了其UID、GID等等信息，而且指定了它的执行类是<code>com.android.server.SystemServe</code>r。</li></ol><ol start="2"><li>调用<code>Zygote.forkSystemServer</code>方法，这个方法会调用操作系统提供的fork方法，fork方法是Linux系统中创建一个新进程的方式，是一个非常特殊的方法，父进程执行fork方法之后，会出现两个几乎完全一样的进程，即原先的父进程和新建的子进程，同时返回fork方法，而且继续执行的代码是一致的，但是不同的是，fork的返回值不相同。在父进程中，会返回子进程的pid（ProcessID），而子进程中会返回0。</li></ol><ol start="3"><li>然后看接下来的代码，if语句判断pid是否为0，所以if语句块中的代码是子进程会执行的，而对于父进程，pid不为零，所以下面会返回null，这也就解释了Step3中为什么是返回null。读者看到这里可以重新返回去看看step3就会明白。（这种写法是非常典型的fork子进程之后的写法）</li></ol><ol start="4"><li>这里重新理一理Step3最后的步骤，在父进程，也就是Zygote进程中，<code>forkSystemServer</code>方法返回了null，于是会执行<code>runSelectLoop</code>方法，而子进程，也就是System进程，返回的是一个runnable，是由<code>forkSystemServer</code>方法中调用的<code>handleSystemServerProcess</code>方法返回的，它嵌套返回到main方法中后，会执行run方法，然后main方法就返回掉了，因为这是System进程了。</li></ol><h4 id="Step3-3-ZygoteServer-runSelectLoop"><a href="#Step3-3-ZygoteServer-runSelectLoop" class="headerlink" title="Step3.3: ZygoteServer.runSelectLoop"></a>Step3.3: ZygoteServer.runSelectLoop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">  </span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">        Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ZygoteConnection connection = peers.get(i);</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the child. We should always have a command to run at this</span></span><br><span class="line">                        <span class="comment">// stage if processOneCommand hasn't called "exec".</span></span><br><span class="line">                        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> command;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the server - we should never have any commands to run.</span></span><br><span class="line">                        <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// We don't know whether the remote side of the socket was closed or</span></span><br><span class="line">                        <span class="comment">// not until we attempt to read from it from processOneCommand. This shows up as</span></span><br><span class="line">                        <span class="comment">// a regular POLLIN event in our regular processing loop.</span></span><br><span class="line">                        <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                            connection.closeSocket();</span><br><span class="line">                            peers.remove(i);</span><br><span class="line">                            fds.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说到这里是Zygote进程死循环等待的地方，是Zygote进程fork出System进程之后，自己等待别的请求的地方。</p><ol><li>首先声明了两个数组，一个是文件描述符数组，第一个元素放的就是<code>mServerSocket</code>。另一个数组是<code>ZygoteConnection</code>数组，从类名就能猜出（当然事实也确实是这样滴）这个类描述的是一个和Zygote进程的连接，也就是说当Zygote接收到请求之后，会将它封装成一个ZygoteConnection对象。</li></ol><ol start="2"><li>开个死循环，调用方法<code>Os.poll</code>，处理轮询状态。poll也是Linux提供的系统调用，用于获知指定的Socket是否有事件到达。可以看到这里创建了一个<code>StructPollfd</code>数组，StructPollfd类是专门与Poll调用配合的一个类，用来描述poll调用的目的和结果，它既包含了一个描述poll监听目的的成员变量，也包含了一个描述已发生事件的成员变量。Poll调用根据传入的StructPollfd，指定监听的socket，指定监听的事件类型，如果没有事件到达，会阻塞在poll方法中，如果有事件到达，则将发生的事件写入StructPollfd对象中，然后返回。</li></ol><ol start="3"><li>可以看到，一开始装入的<code>pollfd</code>是<code>mServerSocket</code>，然后进入poll调用，一旦有事件到达，<code>poll</code>方法将跳出，进入下面的for循环，这时如果i=0，就是AMS请求与Zygote连接（注意这里并非请求创建进程），AMS一般在第一次请求创建进程时会先请求连接，之后如果没有关闭这个链接，则再请求创建之时不用请求连接。Zygote接收到连接请求，则将请求包装后，放入peers中，然后又回到Poll了。注意这里的连接，即<code>ZygoteConnection</code>对象，描述的是和AMS的连接，并不会包括AMS请求创建进程所传递的任何参数。</li></ol><ol start="4"><li>等到AMS再次请求创建时，取出peers中对应的连接，处理、调用<code>processOneCommand</code>方法。这个地方Poll的作用就是在于监听到socket有数据传入了，这些数据才是AMS请求创建进程所传递的数据，而读出这些数据的地方就在<code>processOneCommand</code>方法中。</li></ol><ol start="5"><li>往下又是一个非常典型的fork之后的写法，如果是子进程，就把processOneCommand的结果，即一个Runnable返回出去，在前面提到的ZygoteInit的main方法中会调用它run。父进程会判断是否和AMS已经断开了，通过方法<code>connection.isClosedByPeer()</code>判断的。如果已经断开，则把连接删除掉，如果没有断开，就继续在poll等待AMS请求创建进程。</li></ol><h4 id="Step3-4：ZygoteConnection-processOneCommand"><a href="#Step3-4：ZygoteConnection-processOneCommand" class="headerlink" title="Step3.4：ZygoteConnection.processOneCommand"></a>Step3.4：ZygoteConnection.processOneCommand</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">//从socket中读出要创建的进程的参数</span></span><br><span class="line">    args = readArgumentList();</span><br><span class="line">    ...</span><br><span class="line">    parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">    ...</span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal,parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote, parsedArgs.instructionSet, parsedArgs.appDataDir);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">    zygoteServer.setForkChild();</span><br><span class="line">        <span class="comment">// 子进程中要关掉ServerSocket</span></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.startChildZygote);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 父进程，即Zygote</span></span><br><span class="line">            handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法要处理创建进程的请求，在这里会fork出子进程了。</p><ol><li>调用<code>readArgumentList</code>方法，从<code>mServerSocket</code>中读出AMS放进去的请求参数，并封装一下</li></ol><ol start="2"><li>调用<code>Zygote.forkAndSpecialize</code>方法fork出子进程</li></ol><ol start="3"><li>父进程和子进程分开处理。这个地方涉及到的主要是应用程序进程的启动过程，这里不详述。</li></ol><p><strong><em>到这里Zygote就启动完成啦，在死循环里面等着。</em></strong></p><hr><h2 id="System启动"><a href="#System启动" class="headerlink" title="System启动"></a>System启动</h2><h3 id="Step1-ZygoteInit-handleSystemServerProcess"><a href="#Step1-ZygoteInit-handleSystemServerProcess" class="headerlink" title="Step1: ZygoteInit.handleSystemServerProcess"></a>Step1: ZygoteInit.handleSystemServerProcess</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">                Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Pass the remaining arguments to SystemServer.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这个方法在ZygoteInit里调用的，前面有说到。而且它的调用顺序是在Zygote的死循环开始之前的。</li></ol><ol start="2"><li>它的参数是前面设置好的一个参数，而且是指向子进程的，也就是system进程。其中<code>invokeWith</code>是没有设置的，应该是为了检测进程内存泄露等等Debug用途时才会有值，这一点如果有大大知道，望指点一二。</li></ol><ol start="3"><li>接下来调用<code>ZygoteInit.zygoteInit</code></li></ol><hr><h3 id="Step2-ZygoteInit-zygoteInit"><a href="#Step2-ZygoteInit-zygoteInit" class="headerlink" title="Step2: ZygoteInit.zygoteInit"></a>Step2: ZygoteInit.zygoteInit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>nativeZygoteInit</code>在System进程中启动了一个Binder线程池。这里不详述，关于Binder的知识后面会写文章。</li></ol><ol start="2"><li>调用了<code>RuntimeInit.applicationInit</code></li></ol><hr><h3 id="Step3-RuntimeInit-applicationInit"><a href="#Step3-RuntimeInit-applicationInit" class="headerlink" title="Step3: RuntimeInit.applicationInit"></a>Step3: RuntimeInit.applicationInit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用<code>findStaticMain</code></p><hr><h3 id="Step4-RuntimeInit-findStaticMain"><a href="#Step4-RuntimeInit-findStaticMain" class="headerlink" title="Step4: RuntimeInit.findStaticMain"></a>Step4: RuntimeInit.findStaticMain</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    ...</span><br><span class="line">    cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    ...</span><br><span class="line">    Method m;</span><br><span class="line">    ...</span><br><span class="line">    m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了className指向的类的main方法，也就是<code>SystemServer</code>类的main方法。包装了一下返回了一个<code>MethodAndArgsCaller</code>对象，这个类实现了Runnable接口，于是这个对象会一直返回一直返回到ZygoteInit方法中。</p><p>值得注意的是，这里返回到<code>ZygoteInit.main</code>方法中的进程，不是前面的Zygote进程，而是System进程，是由Zygote进程fork出来的。我们重新看看main方法中的那一段代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"><span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line"><span class="comment">// child (system_server) process.</span></span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">    r.run();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回出来的对象就是r，然后调用了r的run方法，然后把ZygoteInit的main方法返回掉，于是接下来就是<code>SystemServer.main</code>。</p><hr><h3 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main"></a>SystemServer.main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SystemServer().run();</span><br></pre></td></tr></table></figure><p>就调用了这么个方法</p><hr><h3 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer.run"></a>SystemServer.run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        String timezoneProperty =  SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timezone not set; setting to GMT."</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.timezone"</span>, <span class="string">"GMT"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!SystemProperties.get(<span class="string">"persist.sys.language"</span>).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.locale"</span>, languageTag);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.language"</span>, <span class="string">""</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.country"</span>, <span class="string">""</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.localevar"</span>, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Initialize the system context.</span></span><br><span class="line">        createSystemContext();</span><br><span class="line">        <span class="comment">// Create the system service manager.</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext</span><br><span class="line">        ...</span><br><span class="line">        SystemServerInitThreadPool.get();</span><br><span class="line">        );</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startCoreServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是真正运行System进程要初始化的工作的地方！！！</p><ol><li>先设置了一些时区、语言等等</li></ol><ol start="2"><li>创建了一个消息循环Looper</li></ol><ol start="3"><li>创建系统上下文、创建SystemServiceManager,创建一个线程池用来维护系统服务。</li></ol><ol start="4"><li><p>调用各个方法启动各种系统服务，关于系统服务。</p><ul><li><p><code>startBootstrapServices</code>：这里启动一些依赖性比较强的服务。如安装器、设备标识服务、AMS、PackageManagerServices、UserManagerService、电池管理服务、Recovery服务、亮度服务、传感器等等等等。</p></li><li><p><code>startCoreServices</code>：这里启动了UsageStatsService（用户使用情况服务）、WebViewUpdate服务</p></li><li><p><code>startOtherServices</code>：一些杂七杂八的服务，比如闹钟、蓝牙、网络（包括wifi）、媒体、存储等等甚至是statusBar也是单开一个服务的，还有一个重要的是WindowymanagerServices，他在这里的原因是它要等到传感器都初始化好之后，它才能启动，这里顺便一提，还给AMS设置了一个回调systemReady，告诉AMS可以运行非系统的代码了。以及NotificationManager也是在这里创建的。</p></li></ul></li></ol><ol start="5"><li>启动Looper</li></ol><p><strong>到这里System进程就启动完成啦。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android系统 </tag>
            
            <tag> Zygote </tag>
            
            <tag> System </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四火的置顶</title>
      <link href="/2018/10/19/%E5%9B%9B%E7%81%AB%E7%9A%84%E7%BD%AE%E9%A1%B6/"/>
      <url>/2018/10/19/%E5%9B%9B%E7%81%AB%E7%9A%84%E7%BD%AE%E9%A1%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="四火的置顶"><a href="#四火的置顶" class="headerlink" title="四火的置顶"></a>四火的置顶</h1><p>我叫陈钊燚，是华中科技大学软件学院的一名小学生，也是华中科技大学软件学院科创团队和启明学院联创团队Android组的一名小学生。现在主要做一些安卓开发、研究的事情。从大学入学就有开博客的想法，只是困于一开始水平不高，不敢丢人现眼，于是努力学习，这些天有了一些小想法和小总结，感觉有必要正式地记录下来，于是开了这个博客。</p><hr><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ul><li>Android开发记录</li><li>Android源码学习：主要以最新的API28为分析对象，如有不同版本，会在博文开头说明。</li><li>计算机知识记录，包括一些课程中、自学中的感受。</li><li>其他杂七杂八</li></ul><hr><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>此博客主要用于学习交流使用，不涉及任何政治、商业内容，文章总会借鉴一些前辈大佬，但绝不是照抄照搬，记录的都是个人的学习感受。但如果有原作者认为本人有侵犯版权的行为，请发邮件通知我，一定按理处理。</p><p>还有，感谢Android届的几位大大们，特别是罗升阳大大、gityuan大大、郭霖大大，我正是从他们的书和博客中窥探到了Android世界的一二分，特别感谢。</p><p><strong>And 小学生谢谢点开博客的各位，欢迎所有人的评价、建议以及批评。共勉</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 置顶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跳出小世界</title>
      <link href="/2018/10/19/%E8%B7%B3%E5%87%BA%E5%B0%8F%E4%B8%96%E7%95%8C/"/>
      <url>/2018/10/19/%E8%B7%B3%E5%87%BA%E5%B0%8F%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="VPS梯子架设教程"><a href="#VPS梯子架设教程" class="headerlink" title="VPS梯子架设教程"></a>VPS梯子架设教程</h1><p>程序员入门必修课，番羽土啬hhhh。这篇教程教你从0搭梯子</p><p>需要用到的工具和平台有：<del>钱</del>、VPS主机、shadowsocks</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><hr><p>简单讲讲关于墙的原理。我们进行网络访问时，将域名，比如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 通过一层层发向更高级的主机，进行解析成为IP地址（类似127.0.0.1这样的格式），再根据IP发送到真正需要发送的服务器，由服务器返回你需要的数据。</p><p>而提供上层网络服务的节点（ISP）是可以控制的，在CN范围内的网络，都受到GFW的控制，GFW是The Great Fire Wall of China的简写，意指“中国网络防火墙”(字面意为“中国防火长城”)，这是对“国家公共网络监控系统”的俗称，国内简称“国家防火墙”。是用于抵御国外非法、不健康、不合时宜的网站的网络审查机制。境外网站（包括国内的人在境外租用空间开设的网站）一旦被列入黑名单，中国大陆任何地方均不能访问到它。 </p><p>比如google、youtube这样的网站，便是列于GFW的黑名单之中，GFW使用了多种技术对网络请求进行监听和拦截，比如关键字过滤、IP地址封锁、DNS劫持污染等等。这些技术的原理这里就不再详述，简而言之，如果一个请求的目标在黑名单之中，那么这个请求将会被拦截、阻断。</p><p>而想要访问黑名单中的网络，就必须绕开GFW，shadowsocks就是这样一个工具。它对网络请求的发送进行加密，使得数据经过GFW时，无法识别数据的内容，那么GFW会放过这个数据。但有个问题，就是请求是发送出去了，可是返回呢？直接返回的数据还是会被 GFW拦截，所以需要一个部署在国外网站的服务器，它可以直接访问国外网站，我们不是直接请求，而是将请求发送到该服务器，由它代转发这次请求，并将返回的数据由shadowsocks服务端进行加密后，再返回，这样就实现了绕过GFW的目的。</p><p>而还有一种现在没有被GFW墙掉的情况，就是你的网络支持ipv6访问。我们所熟悉的IP地址，多是类似127.0.0.1这样的格式，这种格式是ipv4协议指定的，而在网络高速发展的今天，ipv4地址的总数量出现了不够用的趋势，于是ipv6出现了，ipv6的格式类似ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，而且使用了与ipv4不同的转发技术，而目前GFW还没能对使用ipv6访问的请求进行拦截。所以如果你的网络和主机都支持ipv6，那么你可以直接访问到google。但ipv6目前普及程度不高，主要在国内某些高校的校园网中有应用（例如hust的宿舍区嘻嘻嘻</p><h2 id="VPS服务器"><a href="#VPS服务器" class="headerlink" title="VPS服务器"></a>VPS服务器</h2><p>部署shadowsocks的服务器需要连接在没有墙的国外网络中，这里几个推荐：搬瓦工、vultr。这两个是我个人用过的服务器，体验良好，连接稳定。价格的话，搬瓦工最便宜的价格是一年19.99刀，而vultr最便宜的有一个月2.5刀，但是这个服务是ipv6 only，就是只有ipv6能访问这个主机（我们就是为了能访问国外网站，有ipv6我还要你何用）所以最便宜能用的为一个月3.5刀。</p><p>​    图看这里。这个是vulr的<br><a href="https://i.loli.net/2018/09/22/5ba6387bb5f52.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba6387bb5f52.png" alt></a><br>这个是搬瓦工的。<br><a href="https://i.loli.net/2018/09/22/5ba6389c78ca8.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba6389c78ca8.png" alt></a><br>我们可以观察以下，对两个最便宜的套餐，vultr稍贵一点，但它的硬盘容量是20G，这点如果对于只想使用shadowsocks的大噶其实不重要，但是如果你还想在这台服务器上部署网站，如个人博客之类的，那硬盘容量还是比较重要的。所以看个人需（qian）求（bao）啦。</p><p>购买服务器的时候需要选择操作系统，对于操作系统选择，这里我提个建议，不用选择最新的发布版本。因为网上对于各种坑的教程，对于新版本往往没那么齐全，很多在新版本中才会出现的坑经常查不到，这会耗费很多不必要的时间。个人建议可以选用centOS 6。我这里也是使用这个版本做例子。</p><hr><h2 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h2><h4 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h4><p>有了一个服务器了，接下来要进行shadowsocks服务端的部署。首先要连上服务器。这里我们使用的软件叫xshell（<a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">https://xshell.en.softonic.com/</a> ）安装都按默认即可。打开xshell</p><ul><li><p>这里是我的两个服务器。新安装时应该时没有的。点击“新建”<br><a href="https://i.loli.net/2018/09/22/5ba63e999894f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63e999894f.png" alt></a></p></li><li><p>注意画出来的这几个地方，都是需要填写的。首先是主机和端口号。打开你购买的主机的网站（这里我用搬瓦工做例子）登录后点击Services下的my service，再点击KiwiVM Control Panel<br><a href="https://i.loli.net/2018/09/22/5ba63eba300f9.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63eba300f9.png" alt></a></p></li><li><p>第一次点进来似乎会有初始化界面（当时没留图，不记得了），可以查看到你的密码和端口，这时候就可以记下来，后面会用。</p></li><li><p>在这个页面可以管理控制你的服务器。在这里可以看到你的服务器的信息，可以开关服务器，可以为你的服务器改变系统（点击stop，再左侧Install new OS，选择并确定，稍等几分钟就可以更换你的系统）<br><a href="https://i.loli.net/2018/09/22/5ba63ede4f038.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63ede4f038.png" alt></a></p></li><li><p>可以观察到，这是我的主机，右侧的IP address就是你的IP，SSH Port是你的端口号，把这两个号填入xshell的新建页面中。点击连接。弹出来用户名页面，填入root点击确定（Linux默认root用户是超级用户）<br><a href="https://i.loli.net/2018/09/22/5ba63eff0c81b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63eff0c81b.png" alt></a></p></li></ul><p><a href="https://i.loli.net/2018/09/22/5ba63f44bdb81.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63f44bdb81.png" alt></a></p><ul><li><p>密码？如果初始化的时候有记下来的，可以直接填入，如果没有的，先在Main controls中点击stop，然后点击左侧Root password modification，点击Generate，就可以重置你的密码，它会弹出来一个密码，是一串很蛋疼的序列（在这里不能改，拍个照下来吧）等待主机重启<br><a href="https://i.loli.net/2018/09/22/5ba640202c751.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba640202c751.png" alt></a></p></li><li><p>然后重新打开你的xshell。填入密码登录确定。<br><a href="https://i.loli.net/2018/09/22/5ba640aa1cfb6.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba640aa1cfb6.png" alt></a></p></li><li><p>弹出来这样的字符就说明正确了。这就已经连接上你的服务器了。<br>接下来敲入命令并回车</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure></li><li><p>再输入你自己的新密码并确认一遍密码，之后你的root用户的密码就是这个啦。如果有遗忘了的，可以重新去页面那边重置。</p></li></ul><h4 id="安装Vim"><a href="#安装Vim" class="headerlink" title="安装Vim"></a>安装Vim</h4><p>vim是Linux下很常用的命令行文本编辑器，下面有一些配置文件编辑时需要使用到vim，如果系统内没有vim，首先要安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure><p>vim的用法很多，这里简单说明最基本使用：</p><blockquote><p>​    每次进入时是命令模式，此时是无法输入的，按a或i进入编辑模式<br>编辑内容后，按ESC键返回命令模式<br>​    在命令模式下输入引号“：”可以看到下方会打出一个引号<br>​    输入wq后按回车键保存并退出，如果不想保存，可以直接输入q!后按回车键</p></blockquote><h4 id="安装Pip"><a href="#安装Pip" class="headerlink" title="安装Pip"></a>安装Pip</h4><p>下面要干的事就是安装pip,这是一个Python的包管理工具，我们通过它来下载安装shadowsocks。<br>由于Pip所在的包不在默认的源里，而在EPEL源里，所有首先安装EPEL源，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br></pre></td></tr></table></figure><p>由于CentOS中有一些源被默认禁用，需要先启用EPEL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/epel.repo</span><br></pre></td></tr></table></figure><p>将下面的第一个和第三个的<code>enable=0</code>改成<code>enable=1</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[epel]</span><br><span class="line">  name=Extra Packages for Enterprise Linux 6 - $basearch</span><br><span class="line"><span class="meta"> #</span><span class="bash">baseurl=http://download.fedoraproject.org/pub/epel/6/<span class="variable">$basearch</span></span></span><br><span class="line">  mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-6&amp;arch=$base  arch</span><br><span class="line">  failovermethod=priority</span><br><span class="line">  enabled=0</span><br><span class="line">  gpgcheck=1</span><br><span class="line">  gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</span><br><span class="line">[epel-debuginfo]</span><br><span class="line"> name=Extra Packages for Enterprise Linux 6 - $basearch - Debug</span><br><span class="line"><span class="meta"> #</span><span class="bash">baseurl=http://download.fedoraproject.org/pub/epel/6/<span class="variable">$basearch</span>/debug</span></span><br><span class="line"> mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-6&amp;arch  =$basearch</span><br><span class="line"> failovermethod=priority</span><br><span class="line"> enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</span><br><span class="line"> gpgcheck=1</span><br><span class="line">[epel-source]</span><br><span class="line"> name=Extra Packages for Enterprise Linux 6 - $basearch - Source</span><br><span class="line"><span class="meta">#</span><span class="bash">baseurl=http://download.fedoraproject.org/pub/epel/6/SRPMS</span></span><br><span class="line"> mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-6&amp;arc  h=$basearch</span><br><span class="line"> failovermethod=priority</span><br><span class="line"> enabled=0</span><br><span class="line"> gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</span><br><span class="line"> gpgcheck=1</span><br></pre></td></tr></table></figure><p>安装Pip：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install python-pip</span><br></pre></td></tr></table></figure><p>这里说另一个安装方法，也可以一试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure><h4 id="更新pip源"><a href="#更新pip源" class="headerlink" title="更新pip源"></a>更新pip源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><h4 id="安装依赖模块"><a href="#安装依赖模块" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install python-setuptools m2crypto supervisor</span><br></pre></td></tr></table></figure><p>此时如果出现ImportError: cannot import name main的错误，就先用reboot命令重启下机器，之后再重新执行<code>pip install setuptools</code>。</p><h4 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;服务器ip&quot;,</span><br><span class="line">    &quot;server_port&quot;:自己指定一个端口号,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;自己指定一个密码&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>温馨提示，一定要注意有没有双引号和逗号！！！</strong><br>或者如果你想要开通多个用户的话，也可以这么输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;服务器ip&quot;,</span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">&quot;local_port&quot;:1080,</span><br><span class="line">&quot;port_password&quot;:&#123;</span><br><span class="line">&quot;端口1&quot;:&quot;password0&quot;,</span><br><span class="line">&quot;端口2&quot;:&quot;password1&quot;,</span><br><span class="line">&quot;端口3&quot;:&quot;password2&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;timeout&quot;:300,</span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按ESC : wq 回车 保存</p><p>赋予配置文件执行的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><h4 id="运行shadowsocks服务"><a href="#运行shadowsocks服务" class="headerlink" title="运行shadowsocks服务"></a>运行shadowsocks服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure><h4 id="配置开机自启"><a href="#配置开机自启" class="headerlink" title="配置开机自启"></a>配置开机自启</h4><ul><li>先查一查ssserver在哪里<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis ssserver</span><br></pre></td></tr></table></figure></li></ul><p>如果上面的安装都是正确的，会出现ssserver所在的路径<br><a href="https://i.loli.net/2018/09/23/5ba70494069d1.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/23/5ba70494069d1.png" alt></a></p><ul><li>接下来实现开机自启<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></table></figure></li></ul><p>在文件末尾添加<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line"><span class="meta">#</span><span class="bash"> ssserver路径换成你自己的路径</span></span><br></pre></td></tr></table></figure></p><p>保存退出</p><p>到这里就已经完成了服务端的配置。接下来是客户端。</p><hr><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><h4 id="Windows版本"><a href="#Windows版本" class="headerlink" title="Windows版本"></a>Windows版本</h4><ul><li>打开Github，搜索shadowsocks-windows,点击打开shadowsocks/shadowsocks-windows<br><a href="https://i.loli.net/2018/09/23/5ba705ca42a30.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/23/5ba705ca42a30.png" alt></a></li><li>点击releases，就是我这里显示的40 releases那个地方<br><a href="https://i.loli.net/2018/09/23/5ba7060c3b23f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/23/5ba7060c3b23f.png" alt></a><br>这里会有很多版本，选择其中一个的.zip下载，解压缩即可使用，如果你发现下载的这个版本不能用，有可能是兼容的问题，换一个版本试试</li><li>打开shadowsocks，在这里输入服务器地址、服务器端口、密码、加密方式，这些都是刚刚在服务端配置文件里面配置的。之后点击确定即可。<br><a href="https://i.loli.net/2018/09/23/5ba70692a672f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/23/5ba70692a672f.png" alt></a></li><li>测试一下，在浏览器里输入<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 如果成功打开google的话，你就成功啦。<br>客户端这边也有一些可以配置的，windows在右下角可以右键点击那个小飞机，系统代理模式可以更改，PAC模式和全局模式，这个不详述了。<h4 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h4></li><li>一样是在github上搜索shadowsocks，不过要使用shadowsocks-qt5，有一个AppImage，可以使用<h4 id="Android版本"><a href="#Android版本" class="headerlink" title="Android版本"></a>Android版本</h4></li><li>github上搜索，使用shadowsocks-android版本，这个本人亲测有兼容性问题，多试几个版本，找到能兼容你的手机的<h4 id="iOS版本"><a href="#iOS版本" class="headerlink" title="iOS版本"></a>iOS版本</h4></li><li>iOS的shadowsocks在国内区的Appstore找不到，笔者找了特别久，找到两款替代的，SkipWorld和SsrConnection，这两款软件都可以和shadowsocks客户端作用一样。</li></ul><hr><p>网上还有很多关于shadowsocks优化的教程，包括用锐速、BBr等等，这里不想详述，有兴趣可以去找找看。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shadowsocks </tag>
            
            <tag> 翻墙 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
