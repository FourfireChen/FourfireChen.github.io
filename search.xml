<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Step-by-Step ButterKnife II——实现注解器Syringe</title>
      <link href="/2019/04/19/Step-by-Step%20ButterKnife%20II%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/19/Step-by-Step%20ButterKnife%20II%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-by-Step-ButterKnife-II——实现注解器Syringe"><a href="#Step-by-Step-ButterKnife-II——实现注解器Syringe" class="headerlink" title="Step-by-Step ButterKnife II——实现注解器Syringe"></a>Step-by-Step ButterKnife II——实现注解器Syringe</h1><p>下文将一步步介绍如何实现一个类ButterKnife的注解器。这里将其命名为Syringe（注射器）。以下实现的功能是ButterKnife中最常用的BindView。</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>新建一个Module，选择类型为Java Library，存放注解。</p><p>在该Module下，新建一个自定义注解接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是自定义注解的写法。其中</p><ul><li><p>@interface表示这是一个自定义注解</p></li><li><p>@Target表示这个注解修饰的目标类型，这里使用的ElementType.FIELD表示该自定义注解所注解的目标是一个变量</p></li><li><p>@Retention表示这个注解的类型。</p><p>注解分为三种，分别是源码注解、编译期注解、运行时注解，这三种注解的存在时间不同，如源码级注解只会存在于源代码中，编译期和运行期都不会有注解的标识，而此处以RetentionPolicy.CLASS表示的注解，标示的是该注解在编译期会存在，而过了编译期就被丢弃的注解。</p></li><li><p>int value()：这是自定义注解的一种写法，表示该注解需要接收一个int的值，这个值也就是我们所需要的Id。</p></li></ul><h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>接下来定义注解处理器，新建一个Module，类型同样需要选择为Java Library。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在该Module的build.gradle中添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup:javapoet:1.10.0'</span></span><br><span class="line"><span class="comment">// 这是我上一步的Module的名字，是一个自定义的命名</span></span><br><span class="line">implementation project(<span class="string">":syringeannotation"</span>)</span><br></pre></td></tr></table></figure><h3 id="新建处理器类"><a href="#新建处理器类" class="headerlink" title="新建处理器类"></a>新建处理器类</h3><p>新建一个类，笔者此处命名为SyringeProcessor，作为注解处理器，处理注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyringeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span></span></span><br></pre></td></tr></table></figure><p>APT提供的注解处理器，需要继承自AbstractProcessor，我们的自定义注解处理器也当如此。</p><p>当编译使用该注解处理器的代码时，编译器会调用该注解处理器的方法process，在这个方法中我们就可以进行操作，这个方法也正是我们需要重写的方法。同时我们也需要重写一些其他的辅助方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyringeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(BindView.class.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是<code>getSupportedAnnotationTypes</code>方法。从这个方法返回的注解，将是该注解处理器会拦截下来的元素。也就是说，只有在这返回的注解，才会是这个注解处理器可以处理的。</p><p>接下来就是重写<code>process</code>方法，处理注解。</p><h3 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h3><p>在注解处理器中，将被注解的元素分为几种，分别是</p><table><thead><tr><th>PackageElement</th><th>表示包</th></tr></thead><tbody><tr><td>TypeElement</td><td>表示类或接口</td></tr><tr><td>VariableElement</td><td>表示变量、enum 常量、参数、局部变量</td></tr><tr><td>ExecutableElement</td><td>表示方法</td></tr><tr><td>TypeParameterElement</td><td>表示泛型参数</td></tr></tbody></table><p>这些元素都继承于Element类，有一些通用的方法。常用的如：</p><ul><li>getKind：返回一个枚举值，表示该Element的类型，这里的类型不同于Java中的类型，这里指的是包、方法、变量等等。</li><li>getSimpleName：返回该元素的简单名字。</li><li>getEnclosingElement：返回封装本元素的最里层元素。如对TypeElement调用该方法，返回的是最里层的包，而对一个成员变量调用该方法，返回的则是一个TypeElement。</li><li>getAnnotation：返回该元素的注解。</li></ul><p>贴一下我的处理代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class="line">       Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(BindView.class);</span><br><span class="line">       <span class="comment">// key-value对应的是Activity和每个Activity中注解的元素</span></span><br><span class="line">       Map&lt;TypeElement, List&lt;Element&gt;&gt; activityWithField = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">           <span class="comment">// 改API返回的是封装ele的最内层的元素，bindview注解的是变量，所以拿到的是activity</span></span><br><span class="line">           TypeElement activity = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">           List&lt;Element&gt; bindingView = activityWithField.get(activity);</span><br><span class="line">           <span class="keyword">if</span> (bindingView == <span class="keyword">null</span>) &#123;</span><br><span class="line">               bindingView = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               activityWithField.put(activity, bindingView);</span><br><span class="line">           &#125;</span><br><span class="line">           bindingView.add(element);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;TypeElement, List&lt;Element&gt;&gt; activityWithBindingView : activityWithField.entrySet()) &#123;</span><br><span class="line">           TypeElement activity = activityWithBindingView.getKey();</span><br><span class="line"></span><br><span class="line">           String activityNameStr = activity.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">           List&lt;Element&gt; bindingViews = activityWithBindingView.getValue();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 构造方法</span></span><br><span class="line">           MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder()</span><br><span class="line">                   .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                   .addParameter(ClassName.bestGuess(activityNameStr), <span class="string">"targetActivity"</span>)</span><br><span class="line">                   .addStatement(<span class="string">"this.targetActivity = targetActivity"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 类</span></span><br><span class="line">           TypeSpec.Builder</span><br><span class="line">                   classBuilder =</span><br><span class="line">                   TypeSpec.classBuilder(activityNameStr + <span class="string">"_Syringe"</span>)</span><br><span class="line">                           .addField(ClassName.bestGuess(activityNameStr), <span class="string">"targetActivity"</span>)</span><br><span class="line">                           .addModifiers(Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (Element bindingView : bindingViews) &#123;</span><br><span class="line">               String viewName = bindingView.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> bindingValue = bindingView.getAnnotation(BindView.class).value();</span><br><span class="line"></span><br><span class="line">               constructorBuilder.addStatement(<span class="string">"targetActivity."</span> +</span><br><span class="line">                       viewName +</span><br><span class="line">                       <span class="string">" = targetActivity.findViewById("</span> +</span><br><span class="line">                       bindingValue +</span><br><span class="line">                       <span class="string">");"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           classBuilder.addMethod(constructorBuilder.build());</span><br><span class="line">           JavaFile</span><br><span class="line">                   javaFile =</span><br><span class="line">                   JavaFile.builder(((PackageElement) activity.getEnclosingElement()).getQualifiedName()</span><br><span class="line">                                   .toString(),</span><br><span class="line">                           classBuilder.build()).build();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               javaFile.writeTo(filer);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先从roundEnvironment中获取所有打了BindView注解的元素。这里的元素都是VariableElement。</p></li><li><p>扫一遍，将这些Element按不同的Activity分开来，每个Activity对应一组Element，这里以HashMap存储。依据是VariableElement的getEnclosingElement方法，获取的是TypeElement，也就是对应的Activity的Element。</p></li><li><p>对HashMap做遍历，处理每个Activity及其对应的Element。目标是生成一个这样子的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fourfire.fourfirelib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_Syringe</span> </span>&#123;</span><br><span class="line">  MainActivity targetActivity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_Syringe</span><span class="params">(MainActivity targetActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.targetActivity = targetActivity;</span><br><span class="line">    targetActivity.mButton = targetActivity.findViewById(<span class="number">2131230851</span>);;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法如上文的代码。这里使用的是JavaPoet的API，这是一个支持在代码中生成源代码的库，避免了拼接辅助源代码时大量的字符串操作。</p><ul><li><p>首先生成构造方法。</p><p>addModifiers设置的是方法的访问控制符。</p><p>addParameter添加的是参数，其中该方法接收的第一个参数是要生成的参数的类型，第二个参数是形参名字。这里可以使用ClassName.bestGuess生成第一个参数。</p><p>addStatement添加的是方法的内容。</p></li><li><p>生成类。</p><p>classBuilder方法传入的是类名。</p><p>addField添加该类的成员变量。</p><p>addModifiers设置该类的访问控制符</p><p>接下来遍历该Activity对应的一组Element，即被注解的变量，获取其注解的值，调用构造方法Builder的addStatement生成为这些变量赋值的代码。</p><p>最后将构造方法添加入类的Builder中。</p></li></ul></li><li><p>使用封装好的IO方法写入。</p><p>需要注意的是，此处需要传入包名，包名可以通过activity获取到包，然后再获取该包的全名，则可以得到。</p></li><li><p>return true表示已经处理的注解不需要其他处理器再次处理。</p></li></ul><h3 id="运行注解处理器"><a href="#运行注解处理器" class="headerlink" title="运行注解处理器"></a>运行注解处理器</h3><p>注解处理器写好了，但编译器如何知道要使用该注解处理器呢？这就需要配置。配置文件可以通过编辑<code>META-INF</code>文件。而google提供了一个库，可以自动生成。</p><p>在processor Module的build.gradle依赖中添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.google.auto.service:auto-service:1.0-rc2'</span></span><br></pre></td></tr></table></figure><p>然后对写好的处理器类打注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyringeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SupportedSourceVersion代表的是支持的Java版本</li><li>AutoService就是配置注解处理器，有了这个注解，会自动生成配置文件，而编译器在编译时就会使用该注解处理器。</li></ul><p>当然处理processor Module的配置，对要使用该库的Module也要配置依赖。在app Module的build.gradle依赖中添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是自定义注解所在的Module</span></span><br><span class="line">implementation project(<span class="string">":syringeannotation"</span>)</span><br><span class="line"><span class="comment">// processor Module</span></span><br><span class="line">annotationProcessor project(<span class="string">":syringeprocessor"</span>)</span><br></pre></td></tr></table></figure><p>老版本中使用的不是annotationProcessor，而是apt，但现在的gradle已经淘汰了apt，也不需要做过多的配置，只需要这一行则解决问题。</p><p>build一下项目，在app Module的/build/generated/source/apt/debug下即可看到</p><p><img src="/home/fourfire/Blog/blog_res/2019-04-19-092056_392x262_scrot.png" alt></p><p>至此注解处理器则写好了。但笔者在实现这一段的时候有个坑，就是发生了依赖冲突。autoservice库依赖于guava，而androidx库也依赖与guava的一个module，发生了冲突。如果读者也出现了冲突，在app的build.gradle中，对androidx的guava的listenablefuture移除即可。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">'androidx.appcompat:appcompat:1.1.0-alpha04'</span>) &#123;</span><br><span class="line">   exclude <span class="string">group:</span> <span class="string">'com.google.guava'</span>, <span class="string">module:</span> <span class="string">'listenablefuture'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定接口"><a href="#绑定接口" class="headerlink" title="绑定接口"></a>绑定接口</h2><p>下面将实现绑定接口，也就是ButterKnife.bind的行为。</p><p>由于我将自己实现的整个库命名为Syringe，bind方法我也就命名为syringe，注入的意思。</p><p>同样新建一个Module，选择的是Android Library。新建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Syringe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sringe</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        String activityName = activity.getClass().getName();</span><br><span class="line">        String generateName = activityName + <span class="string">"_Syringe"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(generateName).getConstructor(activity.getClass()).newInstance(activity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实其实现非常简单，通过反射，调用到之前生成的辅助类的构造方法，则一切完成。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindView</span>(R.id.mButton)</span><br><span class="line">    Button mButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Syringe.sringe(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"toast"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用和ButterKnife完全相同。而这里笔者没有实现click注解，所以还是手动setOnClickListener，事实上在ButterKnife中，这个也是通过注解处理可以实现，原理基本一致。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Step-by-Step </tag>
            
            <tag> butterknife </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Step-by-Step ButterKnife I——使用与原理简述</title>
      <link href="/2019/04/18/Step-by-Step%20ButterKnife%20I%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/"/>
      <url>/2019/04/18/Step-by-Step%20ButterKnife%20I%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-by-Step-ButterKnife-I——使用与原理简述"><a href="#Step-by-Step-ButterKnife-I——使用与原理简述" class="headerlink" title="Step-by-Step ButterKnife I——使用与原理简述"></a>Step-by-Step ButterKnife I——使用与原理简述</h1><p>ButterKnife是很好用的基于注解的注入库，可以使用注解生成很多代码，帮助开发者节省很多诸如<code>findViewById</code>等等代码。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>以Activity中一个Button点击为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        button = findViewById(R.id.mButton);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"click"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们常见的写法。一旦控件多了，就需要写很多findViewById，很多click方法（或其中做很多判断）。使用ButterKnife后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindView</span>(R.id.mButton)</span><br><span class="line">    Button mButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@OnClick</span>(R.id.mButton)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"click"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Button变量上打注解，在click方法上打注解。以此可以实现和上一个相同的效果。</p><p>当然ButterKnife不止可以绑定View和onClick方法，还可以绑定各种资源、监听器等等。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>凡事初接触总会有猜测。笔者最初自己想象的ButterKnife的原理，是简单的反射，也是最简单的实现方式。</p><blockquote><p>调用ButterKnife.bind的时候，对传进来的Activity的所有变量遍历一遍，如果打了注解，就为其赋值。</p></blockquote><p>这个方法可以实现，但仔细思考可知，效率低下。即便是如今的Java，对反射的处理已经十分成熟，但可以想象如果Activity的变量有成千上万个，那也是一个非常大的开销。再举一个极端的例子，如果有许多个变量，但需要处理注解的只有一个，此时用这种方法也无法避免要对所有变量遍历一次，效率非常差。</p><p>那么ButterKnife本身是如何实现的呢？</p><p>ButterKnife是基于APT实现的。APT，全称Annotation Processing Tool，是一种处理注解的工具，基于APT，可以实现编译时注解，即在编译器处理源文件中的注解，并且APT提供生成额外源文件的功能，也就是说，在编译器，可以根据源代码上的注解，生成额外的源文件来处理。</p><p>ButterKnife正是采用此方法。</p><p>在编译期间，通过APT，获得所有打过注解的变量、方法，依据这些注解中提供的信息，对目标类（如Activity）的某些变量（如注解了BindView的View）生成辅助类，写好对目标的操作代码，这是以.java，即源代码的形式存在的。</p><p>在调用ButterKnife.bind的时候，调用了生成的辅助类，从而将运行期大量检查注解的时间消耗，提前到了编译期，大大提高了效率。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Step-by-Step </tag>
            
            <tag> butterknife </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Step-by-Step OpenSource 起始章</title>
      <link href="/2019/04/15/Step-by-Step%20OpenSource%20%E8%B5%B7%E5%A7%8B%E7%AB%A0/"/>
      <url>/2019/04/15/Step-by-Step%20OpenSource%20%E8%B5%B7%E5%A7%8B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-by-Step-OpenSource-起始章"><a href="#Step-by-Step-OpenSource-起始章" class="headerlink" title="Step-by-Step OpenSource 起始章"></a>Step-by-Step OpenSource 起始章</h1><p>一直在用开源库，2019年来由于面试，也开始了解一些开源库的源码，但始终觉得需要自己实践一下。这里算是做个总纲吧，列出想实践的各种库。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li>Okhttp：网络框架</li><li>Retrofit：基于OkHttp的网络框架</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>Base：封装一个自己的Base仓库，包括</li><li>ButterKnife：注入</li><li>viewmodel</li><li>livedata</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>litepal</li></ul><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ul><li>log库：帮助打log</li></ul><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul><li>SmartRefreshLayout：RecyclerView下拉刷新库</li><li>ProgressUtil：进度条工具</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Step-by-Step </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ashmem匿名共享内存二——Runtime、Native、Framework</title>
      <link href="/2019/04/11/Ashmem%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BA%8C%E2%80%94%E2%80%94Runtime%E3%80%81Native%E3%80%81Framework/"/>
      <url>/2019/04/11/Ashmem%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BA%8C%E2%80%94%E2%80%94Runtime%E3%80%81Native%E3%80%81Framework/</url>
      
        <content type="html"><![CDATA[<h1 id="Ashmem匿名共享内存二——Runtime、Native、Framework"><a href="#Ashmem匿名共享内存二——Runtime、Native、Framework" class="headerlink" title="Ashmem匿名共享内存二——Runtime、Native、Framework"></a>Ashmem匿名共享内存二——Runtime、Native、Framework</h1><h2 id="Runtime中的cutils"><a href="#Runtime中的cutils" class="headerlink" title="Runtime中的cutils"></a>Runtime中的cutils</h2><p>提供了五个C接口来访问驱动程序。分别是<code>ashmem_create_region</code>创建、<code>ashmem_pin_region</code>锁定、<code>ashmem_unpin_region</code>解锁、<code>ashmem_set_prot_region</code>设置保护位、<code>ashmem_get_size_region</code>设置大小。</p><blockquote><p>region：区域</p></blockquote><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><ul><li>调用文件访问系统调用open，打开设备文件/dev/ashmem。会调用ashmem_open，创建一个ashmem_area结构体，返回一个文件描述符fd。</li><li>通过IO控制命令，为fd对应的匿名共享内存设置名字。</li><li>通过IO控制命令，给fd对应的匿名共享内存设置大小。</li><li>返回fd。</li></ul><h3 id="pin-unpin"><a href="#pin-unpin" class="headerlink" title="pin/unpin"></a>pin/unpin</h3><p>通过IO控制命令，锁定或解锁一小块内存空间，传递的参数是fd、ashmem_pin。</p><h3 id="set-prot"><a href="#set-prot" class="headerlink" title="set prot"></a>set prot</h3><p>通过IO控制命令，设置访问保护位。</p><p>###　get size</p><p>通过IO控制命令，获取匿名共享内存的大小。</p><h2 id="Native层C-接口"><a href="#Native层C-接口" class="headerlink" title="Native层C++接口"></a>Native层C++接口</h2><p>主要提供两个类，MemoryHeapBase和MemoryBase。</p><p>MemoryHeapBase是整块内存的共享，MemoryBase是共享部分内存。</p><p>这两个类都代表的是Service组件，其实就是一套写好的Binder。</p><h3 id="MemoryHeapBase"><a href="#MemoryHeapBase" class="headerlink" title="MemoryHeapBase"></a>MemoryHeapBase</h3><h4 id="IMemoryHeap"><a href="#IMemoryHeap" class="headerlink" title="IMemoryHeap"></a>IMemoryHeap</h4><p>IMemoryHeap类定义了接口，主要有四个函数：<code>getHeapID</code>获取文件描述符、<code>getBase</code>获取映射地址、<code>getSize</code>获取大小、<code>getFlags</code>获取保护位。</p><p>在Binder通讯中，Client端和Server端用的是同一个接口。</p><h4 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h4><p>通过Binder进行通讯，也就是Binder本地对象。</p><h5 id="BnMemoryHeap"><a href="#BnMemoryHeap" class="headerlink" title="BnMemoryHeap"></a>BnMemoryHeap</h5><p>只有onTransact，做中转。转到MemroyHeapBase。</p><h5 id="MemoryHeapBase-1"><a href="#MemoryHeapBase-1" class="headerlink" title="MemoryHeapBase"></a>MemoryHeapBase</h5><p>实现了IMemoryHeap接口。本身成员变量有：mFD文件描述符、mSize大小、mBase映射地址、mFlags访问保护位。</p><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><ul><li>调用ashmem_create_region，创建匿名共享内存，返回文件描述符，也就是mFD。这里会传入名字、大小、访问保护位。</li><li>mapfd，将内存块映射到本进程的地址空间。这里会调用到ashmem_mmap，会创建一个临时文件，即代表匿名共享内存。返回的值是映射的地址mBase。</li></ul><h6 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h6><p>就是返回成员变量</p><h4 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h4><h5 id="BpMemroyHeap"><a href="#BpMemroyHeap" class="headerlink" title="BpMemroyHeap"></a>BpMemroyHeap</h5><p>实现了IMemoryHeap。当Client进程第一次访问这个代理对象时，才会请求Server端返回匿名共享内存的信息。这个类在构造函数中只是赋初值，请求都是在接口实现中做的。</p><h6 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h6><ul><li>获取代理对象。Binder库为Client端维护了一个缓存，如果多个代理应用同个服务，返回的是同一个代理对象。如果代理对象已经存在，则返回，如果不存在，则创建返回。这个代理对象只记录了信息，并没有具体的实现。</li><li>请求。以代理对象的InterfaceDescriptor，通过Binder驱动，发送给服务端的对象，返回整个共享内存的信息，保存在本地。</li></ul><h6 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h6><ul><li>请求得到的共享内存的信息，调用mmap映射到本进程的空间。</li></ul><h6 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h6><ul><li>请求得到的共享内存的信息中有mBase，即一个映射地址，通过该地址则可以访问。</li></ul><h3 id="MemoryBase"><a href="#MemoryBase" class="headerlink" title="MemoryBase"></a>MemoryBase</h3><p>就是基于MemeoryHeapBase，加了偏移量和长度。其内部持有一个MemoryHeapBase实例，而其本身描述的就是这片内存的一小部分，以偏移量和长度表示。</p><h4 id="Server端-1"><a href="#Server端-1" class="headerlink" title="Server端"></a>Server端</h4><h5 id="IMemory"><a href="#IMemory" class="headerlink" title="IMemory"></a>IMemory</h5><p>定义了MemoryBase的服务接口，有四个接口函数<code>getMemory</code>获取内部的MemoryHeapBase、<code>pointer</code>获取MemoryBase描述的一小段内存、<code>size</code>大小、<code>offset</code>偏移量。</p><ul><li>pointer：获取内部的mHeap，然后加上偏移量返回，则可以得到那部分内存。</li></ul><h5 id="MemoryBase-1"><a href="#MemoryBase-1" class="headerlink" title="MemoryBase"></a>MemoryBase</h5><ul><li>getMemory：设置好offset和size，返回heap。</li></ul><h4 id="Client端-1"><a href="#Client端-1" class="headerlink" title="Client端"></a>Client端</h4><h5 id="BpMemroy"><a href="#BpMemroy" class="headerlink" title="BpMemroy"></a>BpMemroy</h5><p>通过Binder和Server端通讯，可以获取mHeap和偏移量。则这个地址可以访问。</p><h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p>Android对Ashmem共享内存提供的Java接口主要有一个类，即MemoryFile。</p><h3 id="MemoryFile"><a href="#MemoryFile" class="headerlink" title="MemoryFile"></a>MemoryFile</h3><p>封装了文件描述符、地址、保护位等等。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>有两种，一个是传入名称和长度，创建匿名共享内存，做映射。另一种是传入文件描述符，直接做映射。</p><p>一般情况下，Server端会用第一个构造函数；Client会用第二个构造函数。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>其他所有方法，包括read、write、getFileDescripter等等，都是调用了JNI，在JNI中使用cutils库提供的接口。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>MemoryFile的通讯，也即其内部的fd的传递，还是通过Binder，当Client端请求Server端的时候，Server端返回一个fd，Client端会使用第二个构造函数，创建、映射，所以一切的访问就是通过共享内存了。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>文件描述符都是通过Binder传递的，Server负责创建匿名共享内存、创建文件、完成映射，然后提供Binder服务，供Client获取文件描述符。Client获取文件描述符之后，再进行映射。接下来就可以通过映射出来的地址值访问了。</p></li><li><p>文件描述符只对本进程有效，但文件结构体只会有一个，多个文件描述符可以指向同一个文件结构体，文件结构体才真正代表着文件。所以Binder并不能直接传递文件描述符，而是在Client生成一个等价的文件描述符。</p><p>在传递文件描述符时，给Binder的协议是TYPE_FD，则Binder驱动在获取到Server端的文件描述符时，会先查到其对应的文件结构体，然后再查询目标进程中还没有使用的文件描述符，再将文件描述符和文件结构体关联，然后返回给Client端。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Linux </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ashmem匿名共享内存一——驱动程序</title>
      <link href="/2019/04/10/Ashmem%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%80%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/04/10/Ashmem%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%80%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Ashmem匿名共享内存一——驱动程序"><a href="#Ashmem匿名共享内存一——驱动程序" class="headerlink" title="Ashmem匿名共享内存一——驱动程序"></a>Ashmem匿名共享内存一——驱动程序</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Ashmem，全称Anonymous  Shared Memory。匿名共享内存。</p><p>Ashmem匿名共享内存是Android系统实现的一种内存共享机制，用于IPC。与传统的Linux内存共享一样，Ashmem也是基于tmpfs实现的，不过Ashmem做了更为细致的内存管理，将整块共享内存切割，可动态回收，动态分配。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="ashmem-area"><a href="#ashmem-area" class="headerlink" title="ashmem_area"></a>ashmem_area</h4><p>用来描述一块共享内存。</p><ul><li><p>name：共享内存的名称。每一个块共享内存的名称都以dev/ashmem开头，如果没有指定名称，则名字就是dev/ashmem。</p></li><li><p>unpinned_list：描述一个解锁内存块列表。ashmem将整个共享内存分为多个小内存块，小内存块有两种状态，一种是锁定，即正在使用，不可回收；一种是解锁，解锁状态下的小内存块可以被回收。这个列表下的地址块互不相交，且按地址值从大到小排列。</p></li><li><p>file：指向临时文件系统tmpfs中的一个文件。</p></li><li><p>size：描述临时文件的大小。这个大小也就是匿名共享内存的大小。</p><blockquote><p>tmpfs：Linux提供的一种临时文件系统，其中的文件存在于内存中，不在硬盘上，也会挂载在文件系统中，不过断电即消失。可以用df命令查看。</p></blockquote></li><li><p>prot_mask：访问保护位。默认是exec|read|write。</p></li></ul><h4 id="ashmem-range"><a href="#ashmem-range" class="headerlink" title="ashmem_range"></a>ashmem_range</h4><p>用来描述一小块解锁内存块。</p><ul><li>unpinned：用于链入宿主共享内存的unpinned列表中。</li><li>lru：用于链入全局LRU链表ashmem_lru_list中，这个链表会在回收的时候用到。</li><li>pgstart/pgend：描述这一小块内存的开始和结束地址，单位是页。</li><li>purged：描述是否已经被回收。</li></ul><h4 id="ashmem-pin"><a href="#ashmem-pin" class="headerlink" title="ashmem_pin"></a>ashmem_pin</h4><p>作为IO控制命令ASHMEM_PIN和ASHMEM_UNPIN的参数，也即解锁和锁定时的参数。成员变量描述了起始地址和长度。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>驱动程序以misc设备文件的形式存在文件系统中，而每块共享内存则以tmpfs的形式存在文件系统中。</p><ul><li><p>创建两个slab缓冲区分配器，分别用来分配ashmem_area和ashmem_range。</p><blockquote><p>slab：缓冲区分配器。虚拟内存的内存分配是以页为单位，但有些小对象所需的内存空间比页大小要小得多，为其分配一整个页是效率低下的。slab分配器持有以页为单位的内存空间，而通过它可以将页再次分割，分配给小对象。</p></blockquote></li><li><p>调用misc_register注册一个匿名共享内存设备。ashmem被当做一个misc设备，以设备文件/dev/ashmem的形式放在文件系统中。应用程序通过它来访问Ashmem驱动程序。</p><blockquote><p>misc：意为杂乱的设备。Linux中专门用来管理特殊设备或者不知如何分类的设备，这些设备公用一个主设备号，以次设备号区分。</p></blockquote><p>ashmem_misc结构体正是ashmem设备文件在内存中的表现形式，其指定了设备文件名字、设备文件操作表（包含打开、关闭、映射、IO控制）。</p></li><li><p>向操作系统内存管理机制注册一个内存回收函数ashmem_shrinker。当系统内存不足时会调用这个函数，这会回收处于解锁状态的小内存块。</p></li></ul><h3 id="设备文件打开"><a href="#设备文件打开" class="headerlink" title="设备文件打开"></a>设备文件打开</h3><p>根据ashmem_misc中的操作表的指定，对设备文件的操作最终都会映射到ashmem.c中实现的各个函数。打开对应了ashmem_open。用户进程调用的是open，返回一个file，而ashmem_open中的参数file就是这个返回值。</p><ul><li>从slab缓冲区中分配一个ashmem_area结构体。做unpinned_list、名称（/dev/ashmem/<name>）、访问保护位的初始化。然后将其赋给file的private_data。</name></li></ul><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>当应用程序调用mmap将<strong>设备文件/dev/ashmem</strong>映射到地址空间时，Ashmem会创建一个临时文件。</p><ul><li>根据文件操作表的映射关系，mmap会被映射到ashmem_mmap，传进来的参数是打开时返回的file，和一个描述内存的结构体vma。</li><li>首先从file中获取ashmem_area。并做大小、访问标记位的判断。</li><li>创建临时文件。调用shmem_file_setup在临时文件tmpfs中创建一个临时文件，打开的文件保存在ashmem_area的成员变量file中。</li><li>将vma的映射文件设置为刚刚创建出来的临时文件，设置其内存操作表，主要改变其缺页方法fault为shmem_fault。其逻辑为：缺页时，先查页面缓冲区，如果有，则映射到缺页的虚拟地址；如果没有到换出设备中查，查到了添入缓冲区；如果再没有，分配新的物理页面，添入缓冲区。通过这种方式，则使用同一个file结构体，就是同一个页面缓冲区，可以映射到不同的vma中，实现了共享内存。</li></ul><h3 id="锁定和解锁"><a href="#锁定和解锁" class="headerlink" title="锁定和解锁"></a>锁定和解锁</h3><p>锁定和解锁主要是通过IO控制命令ASHMEM_PIN和ASHMEM_UNPIN来实现解锁。最终映射到ashmem_pin和ashmem_unpin。</p><ul><li>解锁：宿主共享内存的unpinned_list，按地址从大到小排列，而且互不相交，所以在解锁的时候，要查询顺序，判断是否相交，如果相交要合并；以此得出pgstart和pgend，然后通过slab分配一个ashmem_range结构体。再添入宿主列表unpinned_list和全局列表ashmem_lru_list中。</li><li>锁定：从unpinned_list和ashmem_lru_list中删除。</li></ul><h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p>回收函数ashmem_shrink在驱动程序初始化时就注册好了，当操作系统内存不足时，会调用这个函数，回收。回收的对象就是全局列表ashmem_lru_list中的解锁内存块。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Android系统提供Ashmem匿名共享内存机制，提供驱动程序，驱动程序以misc设备文件的形式存在系统中。命名为/dev/ashmem。</li><li>用户进程通过文件操作/dev/ashmem设备文件，访问Ashmem驱动程序，如打开、关闭、映射等等。</li><li>每块匿名共享内存对应一个临时文件，临时文件基于tmpfs实现，文件则相当于内存空间，其具有页面缓冲区等等内存结构。多个应用进程访问时，使用的是同一个页面缓冲区，以此实现了内存共享。</li><li>匿名共享内存对自己做了切割，将空闲的内存区域描述出来，注册给操作系统，当操作系统内存不足时，会回收这部分内存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Linux </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Studio Gradle代理设置</title>
      <link href="/2019/03/15/Android%20Studio%20Gradle%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/03/15/Android%20Studio%20Gradle%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-Studio-Gradle代理设置"><a href="#Android-Studio-Gradle代理设置" class="headerlink" title="Android Studio Gradle代理设置"></a>Android Studio Gradle代理设置</h1><p>代理一般有两种，一种是socks代理，一种是http代理，gradle针对这两种代理的设置方式不同。</p><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>编辑gradle.properties文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#systemProp.socks.proxyHost=127.0.0.1</span></span><br><span class="line"><span class="comment">#systemProp.socks.proxyPort=1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#systemProp.https.proxyHost=127.0.0.1</span></span><br><span class="line"><span class="comment">#systemProp.https.proxyPort=1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#systemProp.https.proxyHost=socks5://127.0.0.1</span></span><br><span class="line"><span class="comment">#systemProp.https.proxyPort=1080</span></span><br></pre></td></tr></table></figure><h3 id="Socks"><a href="#Socks" class="headerlink" title="Socks"></a>Socks</h3><p>编辑gradle.properties文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080</span><br></pre></td></tr></table></figure><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>个人第一次新建kotlin项目的时候，下载kotlin-compiler没挂代理真的不行，但是之后正常情况下打开，挂了代理真的不行！！有毒。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>View是怎么画出来的（四）——应用程序窗口</title>
      <link href="/2019/03/13/View%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%AA%97%E5%8F%A3/"/>
      <url>/2019/03/13/View%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="View是怎么画出来的（四）——应用程序窗口"><a href="#View是怎么画出来的（四）——应用程序窗口" class="headerlink" title="View是怎么画出来的（四）——应用程序窗口"></a>View是怎么画出来的（四）——应用程序窗口</h1><h2 id="关系概述"><a href="#关系概述" class="headerlink" title="关系概述"></a>关系概述</h2><ul><li><p>Android中，四大组件与UI相关的就只有Activity，Activity在启动之后，会通过一个类型为Session的Binder对象与WMS维持链接，Activity窗口在WMS中对应的是WindowState，描述窗口信息。</p></li><li><p>Android应用进程会通过WMS，请求SurfaceFlinger创建Layer，返回SurfaceLayer Binder对象。则WMS和应用进程中都会持有SurfaceLayer代理对象，都可以和Layer通讯。</p></li><li><p>Activity和ContextImpl是互相持有的，互相可以调用对方。</p></li><li><p>Activity的成员变量有一个mWindow，类型为Window，用来描述一个应用程序窗口，其真正实现类是PhoneWindow，每个Activity都有一个对应的Window。同时Window内也持有Activity作为Callback的实例，可以调用Activity实现的某些接口方法。</p></li><li><p>Window和Activity都持有同一个WindowManager代理。</p></li><li><p>PhoneWindow中持有mDecor和mContentParent，分别指的是DecorView和Content。</p></li><li><p>DecorView的绘制是由ViewRoot来管理的，Activity在启动的过程中，会给自己创建一个ViewRoot对象，也会将PhoneWindow中的mDecor保存在ViewRoot的mView中。所以ViewRoot可以访问DecorView。ViewRoot用来管理绘制、接收IO等事件。</p></li><li><p>ViewRoot继承了Handler，所以它是可以接收消息的。如接收到InputMnager的输入消息、重绘。</p></li><li>ViewRoot持有了mView，也持有WindowManager.LayoutParams，描述的是Activity的UI布局信息，实时上是DecorView的。ViewRoot、DecorView、LayoutParams都保存在WindowManagerImpl中，分别在三个列表中，通过索引号对应一个Activity下的三者。一个应用程序有几个Activity，这三个列表的大小就是多少。</li><li>ViewRoot有一个类型为Surface的成员变量mSurface，这是JAVA层的Surface，其引用了Native层的Surface，这个就是和SurfaceFlinger相关的了，这是SurfaceFlinger机制中，应用程序窗口在应用进程端的描述，一个Surface会对应一个SurfaceControl，用来设置窗口属性，如大小、位置等，但ViewRoot没有SurfaceControl，因为它不需要设置属性，只需要填充内容，即只需要填充纹理。</li><li>Java层的Surface持有一个Canvas，通过它可以访问到图形缓冲区，绘制纹理。而Surface的属性由WMS来管理。</li><li>ViewRoot持有和WMS通讯的Session，当Activity第一次要绘制时，ViewRoot会通过Session请求WMS，WMS请求SurfaceFlinger创建Layer，返回SurfaceLayer，然后封装成Java层的Surface，返回给ViewRoot。</li><li>WMS中，每个Activity对应一个WindowState，其内部持有一个Session和Surface，Session是SufaceSession（每个应用进程对应的多个WindowState所对应的SurfaceSession是一样的），持有mClient，是Native层SurfaceComposerClient对象的地址，用来和SurfaceFlinger通讯。</li></ul><h2 id="运行上下文"><a href="#运行上下文" class="headerlink" title="运行上下文"></a>运行上下文</h2><p>应用程序窗口在运行过程中需要一些资源，这些资源共同构成了上下文，Activity本身就是一个上下文，它继承了ContextThemeWrapper、ContextWrapper，这是一个装饰器模式，真正的实现是ContextWrapper内部持有的ContextImpl，ContextImpl也会通过OuterContext持有Activity。</p><ul><li>创建ContextImpl，然后跟新创建的Activity关联，调用的是attach方法。</li><li>此时创建一个PhoneWindow对象，然后保存为mWindow。</li></ul><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>PhoneWindow在构造方法中，会根据传进来的Context创建一个LayoutInflater，保存在成员变量中。</p><h2 id="View的创建"><a href="#View的创建" class="headerlink" title="View的创建"></a>View的创建</h2><p>每一个Window都有一个ViewRoot，ViewRoot相当于MVC中的Controller，它负责：</p><ul><li>为Ｗindow创建Surface对象。</li><li>调用WMS来管理窗口。</li><li>管理、布局、渲染UI。</li></ul><p>这个过程的起点在开发者重写的onCreate中的，setContentView。</p><h3 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h3><p>这个方法就是给DecorView的content部分填充内容。</p><ul><li>调用的是PhoneWindow的setContentView</li><li>将DecorView加载好，包括title和content。</li><li>然后把传进来的LayoutId，通过Inflater加载进content部分。</li></ul><h2 id="Resume"><a href="#Resume" class="headerlink" title="Resume"></a>Resume</h2><p>这个过程是激活的过程，目的是创建ViewRoot，和DecorView关联起来，然后显示。</p><ul><li>调用Activity的onResume。</li><li>获取PhoneWindow以及DecorView、LayoutParams，调用WindowManagerImpl的addView，创建ViewRoot，然后将三者关联。并将params和父布局params设置到ViewRoot中。</li><li>接下来ViewRoot会调用requestLayout对应用程序窗口UI做第一次布局。</li><li>调用IWindowSession的add方法，通知WMS创建一个WindowState。这里会把W对象传过去，以便WMS可以和应用进程通讯。</li></ul><h2 id="WMS"><a href="#WMS" class="headerlink" title="WMS"></a>WMS</h2><p>应用进程端，每个Activity都持有一个W对象，实现了IWindow窗口，这个对象的作用类似ApplicationThread，也是一个Binder本地对象，ApplicationThread用来和AMS通讯，而W对象用来和WMS通讯。</p><ul><li><p>Activity持有Window，Window持有IWindowSession，可以用其和WMS通讯，作用在于：</p><ul><li>调用add方法，将W对象传递过去，请求WMS创建一个WindowState对象。</li><li>调用remove方法，销毁WindowState对象。</li><li>调用relayout方法，请求WMS对UI进行布局。</li></ul></li><li><p>WMS持有W对象，可以用来：</p><ul><li>Activity组件大小、可见性、焦点性发生变化时，系统会通知WMS，WMS可以通过W通知Activity。</li></ul></li><li><p>AMS和WMS之间有连接，通过一个AppWindowToken来描述。</p><p>Activity在启动时，AMS会为其创建一个ActivityRecord对象，并以此请求WMS创建一个AppWindowToken对象。</p><p>AMS在启动完成之后，会把ActivityRecord返回给应用进程，应用进程在调用add方法时，会把W方法和ActivityRecord一起传给WMS。</p><p>WMS会创建WindowState，此时也会创建和SurfaceSession的连接，然后根据ActivityRecord找到AppWindowToken，把它保存在WindowState中。</p></li></ul><h2 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h2><p>Java层的绘图表面，由两个Surface描述，一个是应用进程端中Window中保存的Surface，一个是WMS中WindowState中保存的Surface，这两个Surface都持有C++的Surface的地址值，指向的是同一个Native层的Surface。</p><p>几个Surface的创建过程：</p><ul><li>应用进程请求WMS创建Surface。</li><li>WMS请求SurfaceFlinger创建Layer，返回Surface。</li><li>WMS获得Surface后保存在WindowState中，再将其返回给应用进程。</li><li>应用进程获得Surface后保存在Window中。</li></ul><h3 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h3><p>这个方法是在Resume过程中调用的，是ViewRoot的成员方法。也是UI绘制的起点。</p><ul><li>检查是否是UI线程（主线程）。</li><li>调用<code>ViewRoot.scheduleTraversals</code>。发送一个DO_TRAVERSAL消息，因为ViewRoot本身是一个Handler，所以会触发其本身的handleMessage方法，会调用performTraversals。</li><li>首先调用mDecor的Measure，触发整棵View树的测量。</li><li>如果当前处理的窗口UI是第一次被处理，或大小、可见性、布局参数发生变化，则会调用relayoutWindow来请求WMS重新布局<strong>系统中的窗口</strong>（注意不是View，是窗口）。</li><li>调用mDecor的layout流程，对当前窗口的UI重新布局。</li><li>draw</li></ul><h3 id="relayoutWindow"><a href="#relayoutWindow" class="headerlink" title="relayoutWindow"></a>relayoutWindow</h3><p>刚刚创建的Java层Surface是没有对应的Native层Surface的，在调用到WMS的relayoutWindow时，才会创建C++的Surface。</p><p>真正的Surface，需要有SurfaceControl、Canvas、Name，这些属性在Surface的构造方法中会初始化，此时会调用JNI方法，在Native层创建SurfaceControl，以及请求SurfaceFlinger创建Layer，返回Surface。</p><h2 id="真正绘制"><a href="#真正绘制" class="headerlink" title="真正绘制"></a>真正绘制</h2><p>应用程序向图形缓冲区填充数据，然后通知SurfaceFlinger绘制。但应用程序进程一般不会直接向图形缓冲区写数据，而是通过一些API来绘制，比如OpenGL、Skia。Skia中，所有的绘制都是在画布Canvas上操作的。所以Android系统将图形缓冲区包装成一个Canvas。</p><p>整个绘制流程是常说的Measure、Layout、Draw。</p><h3 id="Measure"><a href="#Measure" class="headerlink" title="Measure"></a>Measure</h3><p>先传到DecorView的measure方法，参数是最大宽、高，对顶层视图来说，也就是屏幕宽高。接下来会调用自己的onMeasure方法，传进的也是对宽高的期望值。往后就是一个递归过程了。此处以FrameLayout为例。</p><ul><li>触发子View测量。</li><li>子View测量完之后，则可以知道子类的宽高，即mMeasuredWidth和mMeasuredHeight。</li><li>根据子类的宽高，确定自己的宽高，然后设置自己的宽高，设置的是mMeasuredWidth和mMeasuredHeight。</li></ul><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>会调用到View的layout方法。</p><ul><li>首先根据传进来的参数，调用setFrame，设置当前View的位置和大小。</li><li>调用onLayout，重新布局子View。</li><li>布局方式由自己决定，传给子View上下左右，调用的也是子View的layout方法，所以这是一个递归过程。</li></ul><h3 id="Draw"><a href="#Draw" class="headerlink" title="Draw"></a>Draw</h3><ul><li>首先获取mSurface，然后做各种是否需要动画处理的判断。</li><li>判断是否直接以OpenGL来绘制，这样可以直接使用GPU来绘制，如果是的话，获取OpenGL相关的画布，然后调用ViewRoot的draw，触发整个View树的绘制，把Canvas传进去。这种选项需要特殊配置。</li><li>如果不是以OpenGL，进过一系列计算后，请求Surface返回一块画布，然后传给ViewRoot触发绘制。</li><li>绘制完成之后，再调用Surface的方法<code>unlockCanvasAndPost</code>，把Canvas上的东西推给SurfaceFlinger，交给其绘制。</li></ul><p>正常情况下都不会使用OpenGL渲染，下文的流程是非OpenGL流程。</p><h4 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h4><p>调用的是Surface.lockCanvas获取Canvas。</p><ul><li>调用Native层的lockCanvasNative。</li><li>找到C++ Surface，调用lock方法，获取图形缓冲区（这个过程是上一篇文章写的关于应用进程图形缓冲区的获取，dequeueBuffer），封装成SurfaceInfo对象，图形缓冲区地址保存在SurfaceInfo内部。</li><li>找到Java层Surface的成员变量Canvas，把图形缓冲区地址保存到其内部。</li></ul><h4 id="DecorView-draw"><a href="#DecorView-draw" class="headerlink" title="DecorView.draw"></a>DecorView.draw</h4><p>终究也是调用View的draw方法</p><ul><li>首先会对layout的结果做反应，移动Canvas。</li><li>调用onDraw。</li><li>裁剪Canvas，调用子View的draw，把裁剪好的Canvas传进去。</li></ul><h4 id="unlockCanvasAndPost"><a href="#unlockCanvasAndPost" class="headerlink" title="unlockCanvasAndPost"></a>unlockCanvasAndPost</h4><p>会调用JNI方法。请求SurfaceFlinger渲染这块图形缓冲区，queueBuffer。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么在应用端使用Skia API来画Canvas，然后再推到SurfaceFlinger用OpenGL真正渲染？</p>]]></content>
      
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年下半学期学期总结</title>
      <link href="/2019/03/12/2018%E4%B8%8B%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/12/2018%E4%B8%8B%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="2018年下学期学期总结"><a href="#2018年下学期学期总结" class="headerlink" title="2018年下学期学期总结"></a>2018年下学期学期总结</h1><p><strong>2018，很幸福的一年</strong></p><p>​    感觉过暑假、回学校，似乎还是不久前的事情，学期就要结束了。回家，带着满满的收获，期待着回家。</p><p>​    这个学期对我来说是突破的一个学期，从一个计算机领域的小新人，到迈过一道门槛、突破一个瓶颈，成为这个领域的一个小学生。是时候对这个学期做个总结了。</p><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>——<strong>放弃读研想法，决定毕业工作</strong></p><p>​    很开心在学期初做了这个决定，让我这个学期过得很有方向。其实也想了很久，争取读研对现在的我来说，性价比太低、意义不够、风险太大，衔两头顾两边不是我的风格，这个选择也是必然的吧。</p><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><p>——<strong>看了不少，收获不少，细节有待提升</strong></p><p>​    我看书总是比较快，我可能更喜欢多刷而不是仔细，但是这个习惯也导致知识比较容易遗忘，以后还要改进。整理一下这学期主要看的书：</p><ul><li><p>深入理解Java虚拟机：突然想起来这个书还有一两章没看完，这本书算是能让人更深入地了解JAVA究竟是什么样地。</p></li><li><p>Android系统源代码情景分析：看了可能有小一个月。特别感谢这本书，带我突破看源码的瓶颈，从没法看到能自己理逻辑。虽然讲的是挺老的版本，但其实源码的内容改的很少，整体逻辑是很少变得。这本书有些地方看了几次了，还会再看的。</p></li><li><p>C++ Primer Plus：为了看上面那本书，补C++知识，只求能看懂代码，花了一个星期撸了一遍，写是不存在的，看是基本能看懂了。</p></li><li><p>Android进阶解密：讲了热修复和插件化技术，对这方面我一直是存有好奇心的，不得机会了解，后来刘望舒这本书一出来，看到有讲这部分就买了。感觉好神奇，各种手段欺骗系统哈哈哈。这本书还讲了如Activity启动的原理等等，不过有些地方省略了，可能会对新手引起误解。</p></li><li><p>Linux内核设计与实现：了解Linux内核，强推此书。爽。之前翻阅过很多操作系统的书，要不就很晦涩，长篇大论，要不就皮毛，不爽。这本书是面向内核开发者的，讲原理，讲怎么用，深度对我个人来说觉得恰到好处。这本书看得比较细，虽然还是有很多细节忘了，但是对理解内核真的会深一步。</p></li></ul><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>——<strong>继续努力</strong></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>​    源码这块学期初花了好多时间在看一些常见的流程，包括：</p><ul><li>Activity启动</li><li>消息处理机制</li><li>Zygote、System进程启动</li><li>AMS等常见服务的启动</li></ul><p>​    这几个是比较认真看完了的，边看书，边看AOSP，书一般都比较老，自己一直比较好奇最新版本的原理，所以看了书，API28的我也会有看一遍。也写了写博客，遗憾的是只有Zygote、System那部分写完了，其余三个写了一半。</p><p>​    还有几个看一半的：</p><ul><li>Service、Fragment的生命周期</li><li>LayoutInflater</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>​    主要是跟着Linux内核设计与实现那本书看的，那时候觉得很爽，所以也写了挺多博客，发了两篇（IO、Pipe vs eventfd），两篇写完了还没校对更改（VFS、并发），几篇还想写。感觉这部分有很大的空间可以挖掘。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>架构：用了Jetpack撸码，一直感觉架构还能改进，于是有一个星期一直在看github上各大Android项目，学习别人怎么写，学到了很多骚操作。</li><li>Android VM</li><li>ANR</li><li>HashMap</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>——<strong>感恩</strong></p><p>​    手头有一个D工头的项目，感觉有个项目写挺幸福的，很多想法可以在项目上面实践。</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>——<strong>尽力而为，休养至上</strong></p><p>​    这个寒假吧，心里想做的事好多，但执行力能有多高就不清楚了。这个寒假最重要的事情还是好好休养，陪陪家人，以后时间会越来越少。</p><p>​    to-do-list，按优先级排序：</p><ul><li>Linux From Scratch：yx前些天找的那个。很感兴趣。如果有搞头，能搞的话，会花比较多的时间在这个上面。</li><li>项目继续做。</li><li>操作系统：跟着清华大学那个网课学一学，做实验。</li><li>性能优化：找了一些书，想了解一下这方面的东西。</li><li>博客：to-write-list里面有好多，尽可能把之前学的总结一下，写写出来。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>——<strong>再见 and 你好</strong></p><p>​    过得挺好的，感谢生活，感谢身边人的关心。    </p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 2018 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>View是怎么画出来的（三）——应用进程和SurfaceFlinger</title>
      <link href="/2019/03/12/View%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%92%8CSurfaceFlinger/"/>
      <url>/2019/03/12/View%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%92%8CSurfaceFlinger/</url>
      
        <content type="html"><![CDATA[<h1 id="View是怎么画出来的（三）——应用进程和SurfaceFlinger"><a href="#View是怎么画出来的（三）——应用进程和SurfaceFlinger" class="headerlink" title="View是怎么画出来的（三）——应用进程和SurfaceFlinger"></a>View是怎么画出来的（三）——应用进程和SurfaceFlinger</h1><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><ul><li><p>应用进程和SurfaceFlinger的通讯是通过Binder来实现的。每一个Application都和SurfaceFlinger有一个连接，这个连接通过一个类型为Client的Binder对象来描述，应用程序和SurfaceFlinger建立连接之后，会得到一个Client的代理对象，则可以使用这个代理对象了。</p></li><li><p>应用进程和SurfaceFlinger通讯的时候，需要将UI元数据（元数据是指各种属性）发送给SufaceFlinger，这个数据量不是一个小数据，尽管Binder只有一次内存复制，但这个效率还是不够高，所以Android系统中的实现使用的是共享内存，这种共享内存的机制，是Android独有的Ashmem匿名共享内存。</p></li><li><p>应用进程和Client之间有一块共享内存，这块共享内存由类型为SharedClient的对象描述，其中存着多个SharedBufferStack，每一个SharedBufferStack对应SurfacFlinger中的一个Surface，也对应这应用程序中一个窗口。</p><blockquote><p>为什么需要Stack？</p><p>一般UI渲染都会使用“双缓冲”技术，最顶层的显示器这一层是不能够直接绘制的，因为在其上直接绘制会导致画面撕裂、卡顿、模糊等等各种问题，所以多了一层缓冲区，绘制都在缓冲区上，缓冲区和显示屏只进行复制数据的操作，以此保证每一帧的完整性。</p><p>有了Stack，则可以使用多缓冲了，在Android4.1中，据说3缓冲。</p></blockquote></li><li><p>SharedBufferStack的主要内容是一个链表，其元素Buffer保存的是UI元数据，每个元素对应一个GraphicBuffer，这是真正的UI数据。</p><ul><li><strong>应用进程</strong>要更新一个Surface时，找到其对应的SharedBufferStack，取出一个<strong>空闲</strong>的Buffer，然后请求SufaceFlinger为这个Buffer对应的编号分配一个图形缓冲区GraphicBuffer。</li><li>接着把其返回给应用进程，应用进程向其写入UI数据。</li><li>写完之后，其对应的Buffer插入到SharedBufferStack的<strong>非空闲</strong>缓冲区中。</li><li>应用进程通知SurfaceFlinger服务去绘制那些Buffer对应的GraphicBuffer。</li></ul><p>这整个过程传递的只需要是Buffer的编号，因为GraphicBuffer存在SufaceFlinger中，根据编号是可以查到的。</p></li><li><p>应用进程看的是SharedBufferStack的空闲区，而SufaceFlinger用的是其非空闲区。所以为了方便，Android系统分别使用SharedBufferServer和SharedBufferClient来描述非空闲列表和空闲列表。</p></li><li><p>GraphicBuffer内部有一块用来保存UI数据的缓冲区buffer_handle_t，它就是图形缓冲区，是分配于系统帧缓冲区或匿名共享内存。</p></li></ul><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><p>这个过程是以Binder为基础搭建的。</p><ul><li>应用程序首先通过Binder机制获得SufaceFlinger的代理对象。</li><li>每个应用进程与SurfaceFlinger之间有且仅有一个SurfaceClient，以单例实现，所以第一个获取的时候，需要创建，此时会通过SurfaceFlinger代理对象，请求创建一个匿名共享内存，然后返回给应用进程，并在用户进程强转为一个SurfaceClient对象。</li></ul><h2 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h2><p>Suface是一张纸，应用进程负责在上面画东西，而SurfaceFlinger负责把上面的东西拓印到显示屏上。</p><ul><li><p>在SurfaceFlinger中，Surface以Layer来描述。</p><p>Layer是LayerBaseClient、LayerBase的子类。</p><p>Layer持有SharedBufferServer，即SharedBufferStack的待渲染列表。</p><p>Layer还持有一个Binder本地对象SurfaceLayer（类似ApplicationThread），SurfaceFlinger就是用其与应用进程通讯。</p></li><li><p>在应用进程中，每一个Surface是由一个SurfaceControl来创建的，SurfaceControl持有SurfaceLayer的代理对象，也持有一个Surface、SharedBufferClient（SurfaceClient）。</p><p>Surface类继承EGLNativeBase、ANativeWindow，而ANativeWindow是OpenGL中的本地窗口概念，Android通过OpenGL绘制（注意和渲染的区别）UI，所以Surface也是用来描述一个本地对象的。</p></li></ul><p>总：对于一个绘图表面，即上文说的一张纸，应用进程端以Surface描述，SurfaceFlinger端以Layer描述，分别持有SharedBufferClient和SharedBufferServer，用来描述UI元数据缓冲栈。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>应用进程在创建一块Surface时，在应用进程端会创建SurfaceControl对象、一个Surface、一个SharedBufferClient，在SurfaceFlinger端创建一个Layer、一个SurfaceLayer、一个SharedBufferServer。</p><ul><li>通过Binder获取SurfaceFlinger的代理对象。</li><li>通过SurfaceFlinger的代理对象，请求SurfaceFlinger创建一个Surface，返回Surface的各种信息和Surface的代理对象，这个代理对象在服务端的引用是SurfaceLayer。<ul><li>SurfaceFlinger端：<ul><li>正常情况下，会创建一个新的Layer对象（有特殊情况如对原Surface进行模糊，则需要获取之前的Surface）。然后在其内部创建一个SurfaceLayer。</li><li>将创建好的Layer和其对应的应用进程对应的Client对象关联，保存在Client内部的mLayers中。</li><li>将Layer保存到SurfaceFlinger的mCurrentState内部的layersSortedByZ中。</li><li>返回</li></ul></li></ul></li><li>把Surface的各种信息和代理对象封装成SurfaceControl对象。</li></ul><p>接下来应用进程要使用Surface时会调用SurfaceControl的getSurface。</p><ul><li>根据之前已经返回过来的Surface的信息，创建一个Surface</li><li>Surface构造过程中，会创建SharedClient，以及其他的包括SurfaceLayer的代理对象、各种属性等等。</li><li>调用初始化方法：<ul><li>第一部分：设置OpenGL本地窗口的各种回调，比如对空闲缓冲区的获取和对待渲染队列的插入。</li><li>第二部分：设置UI元数据，如旋转方向、纹理等等，以及SharedBufferClient等等。</li></ul></li><li>通知SurfaceFlinger获取、设置ShredBUfferServer。</li></ul><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><ul><li>初始化OpenGL的默认显示屏。</li><li>将Surface转换为OpenGL的Surface—EGLSurface，并获取EGLContext作为绘图上下文。</li><li>从UI元数据缓冲栈中找到一个空闲的元数据缓冲区，将其编号发送给SurfaceFlinger。</li><li>SurfaceFlinger分配一个图形缓冲区，SurfaceFlinger调用进程对应的Layer，进而调用Gralloc模块，直接在帧缓冲区或在内存分配图形缓冲区，这个图形缓冲区以GraphicBuffer描述，这是一块匿名共享内存。这个过程将涉及到gralloc模块的打开、分配等等操作。</li><li>分配完成之后，将图形缓冲区和编号做关联，则以后都可以通过编号来通讯，极大减少通讯数据量。</li><li>返回给应用进程，应用进程将其映射到本进程地址空间，并且UI元数据和图形缓冲区将会做关联，对图形缓冲区做绘制。</li><li>将对应的UI元数据插入待渲染队列。</li><li>通知SurfaceFlinger渲染，SurfaceFlinger的UI渲染线程原本会阻塞，此时会被唤醒，将待渲染队列拿出来，取出图形缓冲区，此时可能有多个图形缓冲区，先进行合并，然后渲染到fb设备的帧缓冲区上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>View是怎么画出来的（二）——SurfaceFlinger</title>
      <link href="/2019/03/11/View%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94SurfaceFlinger/"/>
      <url>/2019/03/11/View%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94SurfaceFlinger/</url>
      
        <content type="html"><![CDATA[<h1 id="View是怎么画出来的（二）——SurfaceFlinger"><a href="#View是怎么画出来的（二）——SurfaceFlinger" class="headerlink" title="View是怎么画出来的（二）——SurfaceFlinger"></a>View是怎么画出来的（二）——SurfaceFlinger</h1><h2 id="整体定义"><a href="#整体定义" class="headerlink" title="整体定义"></a>整体定义</h2><ul><li>持有现状态和下一个状态，以及目前的Surface数组，和显示设备数组。以GraphicPlane对象来管理系统的显示设备。</li><li>有三种线程：<ul><li>Binder线程：用来和用户进程通讯。</li><li>控制台线程：用来和内核通讯，内核一旦需要显示设备做响应，则发送信息，通过该线程处理。</li><li>UI渲染线程：专门负责渲染UI。如果没有渲染任务，则阻塞，有任务则通过gralloc和fb设备，渲染图形。</li></ul></li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul><li><p>Zygote进程启动System进程，SystemServer执行main方法，会加载android_servers库，调用init1函数，会启动由C++写的服务，其中就调用了<code>SurfaceFlinger.instantiate()</code>方法。</p></li><li><p>SurfaceFlinger启动之前，Binder驱动已经启动好了，于是它把自己加入Binder线程池。接下来启动UI渲染线程。再创建一个对象描述显示屏，这个过程中会创建控制台线程，监控控制台事件。</p></li><li><p>开辟一块匿名共享内存，将显示屏的信息写在上面。</p></li></ul><h2 id="管理层次"><a href="#管理层次" class="headerlink" title="管理层次"></a>管理层次</h2><p>SurfaceFlinger用一个GraphicPlane描述显示屏，其内部聚合了一个DisplayHardware，用来访问帧缓冲区，DisplayHardware类内部又包含了一个FramebufferNativeWindow，用来真正描述帧缓冲区，它是连接OpenGL库和Android的UI系统的一个桥梁。</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>SurfaceFlinger是以UI线程为主要处理逻辑，Binder线程和控制台线程分别用来与用户进程和内核做通讯。UI线程拥有一个消息队列，Binder和控制台接收到请求时，向UI线程发送一个消息，进入其队列。如果没有消息，UI线程阻塞。</p><h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><ul><li><p>在SurfaceFlinger中，应用程序窗口以Layer对象描述。SurfaceFlinger持有一个数组，在渲染时会先对Layer的各种属性，判断是否发生了变化。</p></li><li><p>如果有变化，则调用Layer内部的doTransaction。Layer内部有存有描述状态的对象，根据改变，赋值各个属性。</p></li><li>根据变化的属性，设置图形缓冲区的属性。SurefaceFlinger的Layers保存在BufferManager中，并且进行了编号。先标记当前Layer，然后处理其纹理，接下来处理各种区域，如可见区域、透明区域、半透明区域等等，在Layer内部做标记。</li><li>如果SurfaceFlinger服务在编译时指定了宏USE_COMPOSITION_BYPASS，且当前要渲染的应用程序窗口只有一个，且其可见区域不为空，则跳过合并，直接渲染。在应用程序窗口唯一的时候，SurfaceFlinger为其开辟图形缓冲区是在帧缓冲区上的，也就是直接写入数据，则可通知fb渲染。则渲染完成。</li><li><p>其他的情况，先进行各个图形缓冲区的合成，将各个窗口的各种区域合成到主屏幕上。然后再将主屏幕的内容渲染到帧缓冲区。</p></li><li><p>上两步的渲染，最终都是通过Gralloc的post方法，这个方法中会判断图形缓冲区是否在帧缓冲区中分配的，如果是，那就是直接写入的，如果不是，需要通过memcpy复制过去。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>View是怎么画出来的（一）——基础</title>
      <link href="/2019/03/10/View%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/03/10/View%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%BB%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="View是怎么画出来的（一）——基础"><a href="#View是怎么画出来的（一）——基础" class="headerlink" title="View是怎么画出来的（一）——基础"></a>View是怎么画出来的（一）——基础</h1><ul><li>Android设备的显示屏被抽象为一个帧缓冲区（frame buffer,fb）。SurfaceFlinger通过向这个帧缓冲区写入内容来绘制界面。帧缓冲区的所有操作，在硬件抽象层被封装成了Gralloc模块。</li><li>Linux内核启动的时候会创建一个类别为”graphics”，名字为”fb0”的设备，如果有多个显示屏，还会有fbx，这是一个设备文件，描述了显示屏。通过打开fb，获得一个内存，映射到本进程空间之后，对其进行写入，则可以将内容显示出来。</li><li>init系统启动过程中，会启动ueventd进程，这个进程执行的程序和init是同一个，但由条件判断走了不一样的分支。ueventd进程用来管理系统的设备文件，其作用类似Linux中的udev，用于管理设备，如命名、如内核检测到设备插拔，都由ueventd来生成设备文件。</li><li>用户控件的应用进程，先加载gralloc模块，用gralloc申请图形缓冲区，并映射入本进程空间，写入要绘制的内容。然后再把图形缓冲区，通过fb，写入帧缓冲区。</li><li>分配图形缓冲区，有两种方式，一种是直接在帧缓冲区上分配图形缓冲区，这样的话写入的内容就相当于直接写入帧缓冲区。第二种是在进程空间分配图形缓冲区，这使用的是匿名贡献内存。一般情况下，只有SurfaceFlinger会在帧缓冲区直接分配，而用户程序和SurfaceFlinger都会用匿名共享内存。</li><li>在内存中分配图形缓冲区的方法，也是需要通过SurfaceFlinger，由其创建一块匿名共享内存，然后和请求分配的进程共享。</li><li>渲染过程：<ul><li>如果是直接映射在帧缓冲区的，直接写入，然后通知设备，以该图形缓冲区为输出，因为一个帧缓冲区可能有多个图形缓冲区。</li><li>如果是以匿名内存的，写入之后，需要memcpy入帧缓冲区。（这有疑问）</li></ul></li><li>总结：<ul><li>加载Gralloc</li><li>打开Gralloc模块中的gralloc设备和fb设备。</li><li>使用gralloc分配一个匹配屏幕大小的图形缓冲区。</li><li>分配好的图形缓冲区映射到本进程空间。</li><li>将绘制的内容写入图形缓冲区，然后渲染到帧缓冲区（fb设备）去。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记十——文件</title>
      <link href="/2019/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E5%8D%81%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6/"/>
      <url>/2019/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E5%8D%81%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记十——文件"><a href="#操作系统学习简记十——文件" class="headerlink" title="操作系统学习简记十——文件"></a>操作系统学习简记十——文件</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>文件系统：操作系统用来管理持久性数据的子系统，提供存储和访问功能。</li><li>文件：文件系统的基本单位。由文件名标识。存储时分文件头和文件内容，文件头会存储本文件的属性，如大小、位置、命名等等。</li></ul><h2 id="文件系统功能"><a href="#文件系统功能" class="headerlink" title="文件系统功能"></a>文件系统功能</h2><ul><li>分配文件磁盘空间<ul><li>管理文件块</li><li>管理空闲空间</li><li>分配</li></ul></li><li>管理文件集合：抽象化<ul><li>定位</li><li>命名</li><li>文件系统结构：组织方式</li></ul></li><li>数据的可靠和安全</li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>指打开的文件在内存中存储的相应信息，存储在内核的打开文件表中。<strong>一个进程一个打开文件表</strong></p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul><li><p>文件指针：最近一次读写位置。</p></li><li><p>文件打开计数：最后一个进程关闭时，要把文件关闭</p></li><li>文件的磁盘位置</li><li>访问权限</li></ul><h3 id="文件的用户视图"><a href="#文件的用户视图" class="headerlink" title="文件的用户视图"></a>文件的用户视图</h3><ul><li>持久的数据结构</li></ul><h3 id="文件的系统视图"><a href="#文件的系统视图" class="headerlink" title="文件的系统视图"></a>文件的系统视图</h3><p>字节序列的集合，操作系统并不关心数据结构，只当其是数据块的集合。</p><blockquote><p>数据块是逻辑的存储单元</p><p>扇区是物理存储单元</p></blockquote><h3 id="用户视图和系统视图的转换"><a href="#用户视图和系统视图的转换" class="headerlink" title="用户视图和系统视图的转换"></a>用户视图和系统视图的转换</h3><ul><li>读文件：获取字节所在的数据块，必须以块为单位，返回需要的内容。</li><li>写文件：获取数据块，修改对应部分，写回磁盘。</li></ul><p><strong>基本操作单位是数据块，即使只访问一个字节，也必须取出整个数据块</strong></p><h3 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h3><ul><li>顺序访问：按字节依次访问</li><li>随机访问：从中间读写</li><li>索引访问：按数据特征索引。这个操作系统比较少完全实现，一般通过数据库实现。</li></ul><h3 id="文件内部结构"><a href="#文件内部结构" class="headerlink" title="文件内部结构"></a>文件内部结构</h3><ul><li>无结构：字节序列</li><li>简单记录：分列、固定长度</li><li>复杂结构：文档、可执行等等</li></ul><h2 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>以目录的形式组织，目录也是一种特殊的文件。</p><h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4><ul><li>文件名的线性列表，元素类型是指向文件的指针</li><li>哈系表</li></ul><h3 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h3><ul><li>硬链接：多个文件项指向一个文件</li><li>软链接：以快捷方式指向其他文件</li></ul><h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><ul><li>磁盘文件系统：存在磁盘上，如FAT、EXT2等等</li><li>数据库文件系统：可识别文件特征</li><li>日志文件系统：记录文件系统发生的事件</li><li>网络/分布式文件系统</li><li>特殊/虚拟文件系统：如管道等</li></ul><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>封装统一的文件管理接口，将不同的文件系统，对上层提供相同的抽象。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>文件卷控制块：superblock。一个文件系统一个控制块，记录文件系统信息、块大小、空余块等等信息。</li><li>文件控制块：vnode/inode。每个文件一个，记录文件的详细信息、访问权限、拥有者、大小、位置等等。</li><li>目录项：dentry。每个目录一个目录项，树状记录。</li></ul><p>所以整个文件系统的组织视图为：</p><p>文件卷控制块-&gt;目录项-&gt;文件控制块-&gt;数据块</p><p>由此组成树。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>卷控制块、文件控制块、目录节点都会持久化存储在外存中，在需要的时候加载如内存。</p><ul><li><p>卷控制块：挂载时加载入内存</p></li><li><p>文件控制块：访问相应文件时加载</p></li><li>目录节点：遍历到的时候加载</li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记九——进程间通讯</title>
      <link href="/2019/02/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%B9%9D%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
      <url>/2019/02/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%B9%9D%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记九——进程间通讯"><a href="#操作系统学习简记九——进程间通讯" class="headerlink" title="操作系统学习简记九——进程间通讯"></a>操作系统学习简记九——进程间通讯</h1><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><h3 id="直接通讯"><a href="#直接通讯" class="headerlink" title="直接通讯"></a>直接通讯</h3><p>在非内核空间建立通讯链路</p><ul><li>需要对双方进行命名</li><li>建立通讯链路</li></ul><h3 id="间接通讯"><a href="#间接通讯" class="headerlink" title="间接通讯"></a>间接通讯</h3><p>通过内核空间做通讯</p><ul><li>需要内核消息队列</li></ul><h3 id="通讯链路"><a href="#通讯链路" class="headerlink" title="通讯链路"></a>通讯链路</h3><ul><li>0容量：发送方必须等待接受方。</li><li>有限容量：满时，发送方等待。</li><li>无线容量：不需要等待。</li></ul><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>如ctrl+C就是使用信号，信号包括SIGHILL,SIGSTOP</p><h4 id="接收处理"><a href="#接收处理" class="headerlink" title="接收处理"></a>接收处理</h4><ul><li>捕获：信号处理函数被调用</li><li>忽略：如进程中止时</li><li>屏蔽：暂时不接收，如登录时</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>注册：将处理程序告知内核</li><li>发送：发送给内核</li><li>处理：内核找到处理程序，执行处理程序</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>基于<strong>内存文件</strong></p><ul><li><p>利用子进程fork时继承文件描述符或命名文件</p></li><li><p>创建：返回一个文件描述符数组，长度为2,一个读一个写。</p></li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>内核维护</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>统一块物理区域，映射到不同的页表</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记八——同步互斥</title>
      <link href="/2019/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E5%85%AB%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
      <url>/2019/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E5%85%AB%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记八——同步互斥"><a href="#操作系统学习简记八——同步互斥" class="headerlink" title="操作系统学习简记八——同步互斥"></a>操作系统学习简记八——同步互斥</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在允许并发执行的同时，保证一些操作是原子操作。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>一个进程占用资源，其它资源就必须等待</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>循环等待</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>进程轮流占用资源，一个资源一直得不到资源</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>需要保证进程互斥的区域</p><h3 id="进入区"><a href="#进入区" class="headerlink" title="进入区"></a>进入区</h3><p>即将进入临界区的区域，需要在此处做互斥处理</p><h3 id="退出区"><a href="#退出区" class="headerlink" title="退出区"></a>退出区</h3><p>临界区结束的区域，需要做锁释放</p><h2 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h2><ul><li>空闲则入</li><li>忙则等待：临界区有进程了，就不能进入</li><li>有限等待：不能无限等待</li><li>让权等待（可选）：暂时不能进入临界区的进程，应该释放CPU</li></ul><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="禁用中断"><a href="#禁用中断" class="headerlink" title="禁用中断"></a>禁用中断</h3><p>没有中断，没有上下文切换，没有并发。但会导致中断没有处理，一切中断都会延迟到中断被启用之后才会处理。这个一般由体系结构提供指令来实现。</p><h3 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h3><p>手动做while和标记位的处理。</p><ul><li>先做判断，后做标签：可能两个同时先做判断，然后再进入，贴标签。</li><li>先贴标签，后做判断：可能导致两个都进不去。</li><li>先申请进入，再打标签，再同时判断申请和标签，可以完成。Peterson算法。</li></ul><h3 id="高级抽象（硬件）"><a href="#高级抽象（硬件）" class="headerlink" title="高级抽象（硬件）"></a>高级抽象（硬件）</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>一个抽象的数据结构，由一个二进制变量（标记锁定和解锁）、一个Acquire行为、一个Release行为组成。</p><ul><li>Acquire：锁释放前一直等待，然后得到锁</li><li>Release：唤醒所有正在等待的锁</li></ul><p>基于原子操作指令，包括测试置位、交换指令。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>和软件实现稍微不同，引入操作系统作为管理者。</p><p>由一个整型共享变量（记录共享资源数）和两个原子操作组成。</p><ul><li>P()：sem减1,如果小于0,进入等待，否则继续。</li><li>V()：sem加1,如果sem&lt;=0，唤醒一个等待进程，因为说明有线程在等待。</li></ul><p>事实上类似软件实现，但由操作系统保证其原子性。</p><h4 id="管程？？"><a href="#管程？？" class="headerlink" title="管程？？"></a>管程？？</h4><ul><li>任一时刻只有一个线程执行管程代码。</li><li>与临界区不同的是，正在管程中的线程可以临时放弃管程的互斥访问。</li></ul><h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><ul><li>预防：打破死锁的必要条件，如在进程申请资源时，将其所有持有的资源释放。</li><li>避免：先判断是否会出现死锁，不会再分配给你。确保不会出现环形等待。</li></ul><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>判断自己的资源是否足够能满足请求，如果不能满足的话，直接拒绝。</p><p>首先判断线程整个流程需要的最大资源，减去已分配的资源，可以得到还需要多少资源。此时和当前可用资源做比较，如果存在可以完全满足的线程，就分配给它，则它执行完之后，可以回收其占用的资源。由此迭代可以得到安全序列。</p><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>允许系统进入死锁，定期检查，如果出现死锁，则调用恢复机制。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记七——处理机调度</title>
      <link href="/2019/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%B8%83%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
      <url>/2019/02/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%B8%83%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记七——处理机调度"><a href="#操作系统学习简记七——处理机调度" class="headerlink" title="操作系统学习简记七——处理机调度"></a>操作系统学习简记七——处理机调度</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><ul><li><p>从就绪队列中挑选下一个占用CPU运行的进程；</p></li><li><p>从多个可用CPU中挑选就绪进程可以使用的CPU资源。</p></li></ul><h3 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h3><p>挑选进程和CPU的内核函数，内容包括：</p><ul><li>调度策略</li><li>调度时机</li></ul><h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><h4 id="运行调度程序的条件"><a href="#运行调度程序的条件" class="headerlink" title="运行调度程序的条件"></a>运行调度程序的条件</h4><p>状态发生变化时</p><h5 id="非抢占系统"><a href="#非抢占系统" class="headerlink" title="非抢占系统"></a>非抢占系统</h5><p>当前进程主动放弃</p><ul><li>有进程从运行切换到等待；</li><li>有进程退出</li></ul><h5 id="可抢占系统"><a href="#可抢占系统" class="headerlink" title="可抢占系统"></a>可抢占系统</h5><ul><li>中断服务程序响应完成</li><li>当前进程被抢占，有两种情况<ul><li>时间片用完</li><li>进程从等待切换到就绪</li></ul></li></ul><h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><p>如何从就绪队列中选择下一个执行进程</p><h3 id="考核指标"><a href="#考核指标" class="headerlink" title="考核指标"></a>考核指标</h3><p>如何判断一个调度算法好坏？</p><p>通常情况下进程在CPU计算和IO操作之间交替，基于此，衡量标准有几种：</p><ul><li>CPU使用率：CPU处于忙时间百分比；</li><li>吞吐量：单位时间内完成的进程数量；</li><li>周转时间：进程从初始化到结束的总时间；</li><li>等待时间：进程在就绪队列中的总时间；</li><li>响应时间：从提交请求到产生响应花费的时间；</li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>响应：<ul><li>响应时间低，低延迟；</li><li>响应时间稳定，不抖动；</li></ul></li><li>吞吐量：增加吞吐量<ul><li>减少开销（操作系统开销，上下文切换）；</li><li>系统资源的更高效利用；</li><li>减少等待时间；</li></ul></li><li>公平性</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="FCFS-First-Come-First-Serve"><a href="#FCFS-First-Come-First-Serve" class="headerlink" title="FCFS(First Come, First Serve)"></a>FCFS(First Come, First Serve)</h4><p>上一个进程主动让出CPU时，按照进程进入就绪状态的顺序，选出下一个进程。</p><p>该算法周转时间和排列顺序有关，短进程排前面，平均周转时间短。</p><ul><li>缺点：<ul><li>平均等待时间波动大；</li><li>IO资源利用率低；</li></ul></li></ul><h4 id="短进程优先"><a href="#短进程优先" class="headerlink" title="短进程优先"></a>短进程优先</h4><h5 id="短进程优先算法（SPN）"><a href="#短进程优先算法（SPN）" class="headerlink" title="短进程优先算法（SPN）"></a>短进程优先算法（SPN）</h5><p>对FCFS的优化，选择预期执行时间最短的进程，但这个预期时间只是估计值。</p><ul><li><p>短剩余时间优先</p><p>  如果目前进程执行时间比新进来的时间长，抢占</p></li><li><p>缺点</p><ul><li>短进程太多会使长进程总是得不到资源</li><li>预知未来<ul><li>用户进程指定；</li><li>已历史时间预测未来；</li></ul></li></ul></li></ul><h4 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h4><p>等待时间+执行时间/执行时间，这个值越大，执行优先级越高。</p><h4 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h4><ul><li>时间片：处理机资源分配的基本时间单位；</li><li>思路：时间片结束后，按FCFS选择下一个；</li><li>开销：<ul><li>比较频繁的上下文切换</li></ul></li><li>时间片大小：通常选择维持上下文切换开销处于百分之一左右；</li></ul><h4 id="多级反馈队列（MQ）"><a href="#多级反馈队列（MQ）" class="headerlink" title="多级反馈队列（MQ）"></a>多级反馈队列（MQ）</h4><ul><li><p>多级队列</p><p>  就绪队列分为多个独立子队列。</p><ul><li>思路：<ul><li>队列内部分别独立调度策略，如前台队列RR，后台FCFS</li><li>队列间调度<ul><li>固定时间片</li></ul></li></ul></li></ul></li><li><p>多级反馈队列：对多级队列的改进</p><p>  进程可在不同队列之间移动</p></li></ul><h4 id="公平共享调度（FSS）"><a href="#公平共享调度（FSS）" class="headerlink" title="公平共享调度（FSS）"></a>公平共享调度（FSS）</h4><p>以用户为单位，做优先级分配。</p><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>正确性依赖于时间和功能两方面的操作系统，也即需要在一定的时间内完成某些任务，才算正确。</p><p>这种操作系统的衡量指标是对时间的约束性。</p><h3 id="实时任务"><a href="#实时任务" class="headerlink" title="实时任务"></a>实时任务</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>一次计算、文件读取等等。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>需要的资源</li><li>定时的参数：请求时间、截止时间</li></ul><h4 id="周期实时任务"><a href="#周期实时任务" class="headerlink" title="周期实时任务"></a>周期实时任务</h4><p>有规律性的重复，于是会有周期的概念。</p><h4 id="硬时限"><a href="#硬时限" class="headerlink" title="硬时限"></a>硬时限</h4><p>错过任务时限会有严重后果，操作系统必须提前验证能不能完成。</p><h4 id="软时限"><a href="#软时限" class="headerlink" title="软时限"></a>软时限</h4><p>如果不能满足，可以降低要求。</p><h4 id="可调度性"><a href="#可调度性" class="headerlink" title="可调度性"></a>可调度性</h4><p>可以保证多任务下，所有任务都满足其时限。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h5 id="速率单调调度算法"><a href="#速率单调调度算法" class="headerlink" title="速率单调调度算法"></a>速率单调调度算法</h5><p>周期越短优先级越高</p><h4 id="最早截止时间优先"><a href="#最早截止时间优先" class="headerlink" title="最早截止时间优先"></a>最早截止时间优先</h4><p>截至时间越早优先级越高</p><h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>实现负载共享，尽可能多利用资源。</p><h3 id="对称多处理器调度"><a href="#对称多处理器调度" class="headerlink" title="对称多处理器调度"></a>对称多处理器调度</h3><ul><li><p>每个处理器可以有自己的调度算法</p></li><li><p>访问共享资源时需要同步</p></li></ul><h4 id="进程分配"><a href="#进程分配" class="headerlink" title="进程分配"></a>进程分配</h4><h5 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h5><p>进程在开始时被分配一个处理器，之后就固定由其执行。每个处理机都有自己的就绪队列。可能导致负载不均。</p><h5 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h5><ul><li>进程可分配到任意空闲处理机</li><li>所有处理机共享一个就绪队列，则需要同步</li><li>调度开销较大</li><li>负载均衡</li></ul><h2 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>高优先级长时间等待低优先级所占用的资源。</p><p>如，高优先级P1等待低优先级P2的资源，此时有另外的进程优先级高于P2在长时间运行。</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><h4 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h4><p>占用资源的低优先级进程继承需要资源的高优先级的优先级</p><h4 id="优先级天花板"><a href="#优先级天花板" class="headerlink" title="优先级天花板"></a>优先级天花板</h4><p>占用资源进程的优先级提高到所有可能申请该资源的进程的最高级相同</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记五——线程基础</title>
      <link href="/2019/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%BA%94%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%BA%94%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记五——线程基础"><a href="#操作系统学习简记五——线程基础" class="headerlink" title="操作系统学习简记五——线程基础"></a>操作系统学习简记五——线程基础</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>需要一组实体，满足：</p><ul><li><p>比进程更加轻量级；</p></li><li><p>实体之间可以并发执行；</p></li><li>实体之间共享相同的地址空间。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程中的一条执行流程。</p><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><p>线程控制块（TCB）</p><p>包含的信息：主要是状态记录信息，如PC、SP、状态等等，但这些资源本身是属于进程的。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>二者比较</p><ul><li>进程是资源分配单位，线程是CPU调度单位；</li><li>进程拥有完整资源平台，线程只独享部分资源；</li><li>二者都有就绪、阻塞、执行三种状态，同样具有状态间的转换；</li><li>线程能减少并发执行的时间和空间开销<ul><li>创建、终止时间短；</li><li>切换快；</li><li>统一进程内共享资源，通讯不用通过内核。</li></ul></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一般有三种实现方式，不同的操作系统选择的实现方式可能不同：</p><ul><li>用户线程：在用户空间实现，由应用程序管理。如POSIX Pthreads、Solaris threads；</li><li>内核线程：在内核中实现，由内核管理。如Windows、Linux；</li><li>轻量级线程：在内核中实现，支持用户线程？？。</li></ul><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>由某些库支持，被应用进程调用、管理，操作系统看不见这些线程（也即看不到TCB），操作系统只能看到进程。</p><p>用户空间实现的用户线程，不依赖于操作系统的内核，有一组<strong>用户级</strong>的线程库函数来管理。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>不需要操作系统了解用户线程的存在，可以用于本身不支持线程技术的操作系统；</li><li>用户线程的切换也是由线程库函数来完成，由于不依赖内核，所以不涉及用户态和内核态的切换，速度很快；</li><li>允许每个进程拥有自定义的线程调度算法；</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>如果线程发起了一个阻塞型的系统调用，会导致整个进程陷入阻塞，包括其他线程。这是因为操作系统只能感知到进程执行了阻塞操作；</li><li><p>当一个线程开始执行后，除非它主动交出CPU使用权，否则它所在的进程中的其它线程无法执行。这也是因为操作系统感知不到线程的存在，所以它无法对同一个进程内的线程进行调度。</p></li><li><p>由于时间片是分配给进程的，进程才是资源平台，所以多线程情况下的进程，内核感知不到，分配的时间片可能不合理。</p></li></ul><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>线程通过内核管理，即TCB处于内核中。Window就是这么实现的。</p><h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p>由内核支持的用户进程。</p><p>一个进程拥有多个轻量级进程，每个轻量级进程由一个的内核线程来支持（有可能多个轻量级进程由同一个内核线程支持）。</p><p>Solaris和Linux就是这么实现的。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记六——进程管理</title>
      <link href="/2019/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E5%85%AD%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2019/02/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E5%85%AD%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记六——进程管理"><a href="#操作系统学习简记六——进程管理" class="headerlink" title="操作系统学习简记六——进程管理"></a>操作系统学习简记六——进程管理</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><ul><li>暂停当前运行进程，从运行状态变成其他状态；</li><li>调度另一个进程从就绪状态变为运行状态。</li></ul><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><h3 id="Unix进程创建：fork-exec"><a href="#Unix进程创建：fork-exec" class="headerlink" title="Unix进程创建：fork/exec"></a>Unix进程创建：fork/exec</h3><ul><li><p>fork将一个进程复制为两个</p><p>  parent(old PID), child(new PID)</p></li><li><p>exec用新程序重写当前进程的内存（常用于fork后，为新进程做加载执行）</p><p>  PID没有改变</p></li></ul><h3 id="系统初始化的进程"><a href="#系统初始化的进程" class="headerlink" title="系统初始化的进程"></a>系统初始化的进程</h3><p>ucore中，系统初始化执行<code>proc_init()</code>函数，这个函数会创建：</p><ul><li>IdleProc空闲进程：如果系统处于空闲状态，会执行空闲进程。这种进程的优先级是最低的。</li><li>InitProc初始化进程。</li></ul><h3 id="fork开销"><a href="#fork开销" class="headerlink" title="fork开销"></a>fork开销</h3><ul><li>子进程分配内存</li><li>复制父进程内存和cpu寄存器</li></ul><p>但是在很多情况下fork后都会执行exec，此时复制就是多余的，这部分开销是可以节约的。Win就是通过一个系统调用完成了创建和加载，节省了复制这一步。现代操作系统的做法：</p><ul><li>UNIX早期提供了vfork，一种轻量级的fork，也支持不复制；</li><li>现在的复制都是写时复制，也就意味着一旦调用了exec，会把整个内存覆盖，那其实复制这一步就不会执行。</li></ul><h2 id="进程加载"><a href="#进程加载" class="headerlink" title="进程加载"></a>进程加载</h2><ul><li>从外存上读取程序，并覆盖整个内存；</li><li>堆、栈等都会被覆盖。</li></ul><h2 id="进程等待和结束"><a href="#进程等待和结束" class="headerlink" title="进程等待和结束"></a>进程等待和结束</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><ul><li><p><code>wait()</code>系统调用用于父进程等待子进程的结束</p><ul><li>子进程结束时调用<code>exit()</code>向父进程返回一个值，等待父进程的处理；</li><li>父进程通过<code>wait()</code>接收并处理返回值；</li></ul></li><li><p>wait()<code>的两种情况：父进程调用</code>wait()`后：</p><ul><li>子进程还存活，父进程进入等待状态，等待子进程返回，直到某子进程执行<code>exit()</code>；</li><li>有僵尸子进程在等待，即子进程在父进程执行<code>wait()</code>前就调用了<code>exit()</code>，这时子进程在等待父进程处理，则此时<code>wait()</code>立即返回；</li><li>无子进程结束，直接返回。</li></ul></li></ul><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>完成进程资源的回收</p><ul><li><p>结果</p><ul><li>返回一个值给父进程；</li><li>关闭文件等资源；</li><li>释放内存；</li><li><p>释放大部分内核数据结构；</p></li><li><p>检查父进程是否存活</p><ul><li>存活，自己进入僵尸状态，等待父进程的处理；</li><li>不存活，释放所有数据结构；</li></ul></li><li>清理所有等待的僵尸进程。</li></ul></li></ul><h2 id="其他进程控制"><a href="#其他进程控制" class="headerlink" title="其他进程控制"></a>其他进程控制</h2><h3 id="优先级控制"><a href="#优先级控制" class="headerlink" title="优先级控制"></a>优先级控制</h3><ul><li><p><code>nice()</code>调用指定进程的初始优先级；</p></li><li><p>Unix中进程优先级会随时间衰减；</p></li></ul><h3 id="调试支持"><a href="#调试支持" class="headerlink" title="调试支持"></a>调试支持</h3><p><code>ptrace()</code>允许一个进程查看、控制另一个进程；</p><h3 id="定时"><a href="#定时" class="headerlink" title="定时"></a>定时</h3><p><code>sleep()</code>让进程在等待队列等待，定时自己醒。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记四——进程基础</title>
      <link href="/2019/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E5%9B%9B%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E5%9B%9B%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记四——进程基础"><a href="#操作系统学习简记四——进程基础" class="headerlink" title="操作系统学习简记四——进程基础"></a>操作系统学习简记四——进程基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>包含了正在运行的一个程序的所有状态信息</p><ul><li>程序指令；</li><li>数据；</li><li><p>程序计数器，指示下一条指令；</p></li><li><p>通用寄存器、堆栈；</p></li><li>系统资源（如打开的文件）；</li></ul><h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><ul><li><p>动态性；</p></li><li><p>并发性；</p><p>  注：并发与并行不同。时间粒度不同。并发是指一段时间内有多个进程同时运行；并行是指在一个时刻有多个进程运行，是需要多核才能实现的。</p></li><li><p>独立性：通过页表做管理，使得不同进程之间互补影响；</p></li><li><p>制约性：访问共享资源或同步而产生的互相制约的关系。</p></li></ul><h3 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h3><p>进程控制块（Process Control Block, PCB）</p><p>操作系统为每个进程维护了一个PCB，描述了该进程的所有状态信息，PCB是进程存在的唯一标志。</p><ul><li>进程的创建：生成一个PCB；</li><li>进程的中止：回收PCB；</li><li>进程的组织管理：组织管理PCB。</li></ul><h4 id="PCB包含的信息"><a href="#PCB包含的信息" class="headerlink" title="PCB包含的信息"></a>PCB包含的信息</h4><ul><li>进程标识信息。本进程标识、父进程标识、用户标识；</li><li>处理机状态，保存进程的运行现场信息。<ul><li>用户可用寄存器；</li><li>控制和状态寄存器，如程序计数器、程序状态字；</li><li>栈指针。</li></ul></li><li>进程控制信息，描述进程当前的执行特征。<ul><li>调度和状态信息，描述进程当前运行状态；</li><li>进程间通讯信息，记录进程间通信相关的信息，如各种标识、信号等，这些信息存在于<strong>接收方</strong>的PCB中；</li><li>存储管理信息，包含指向本进程映像内存空间的数据结构；</li><li>进程使用资源，由进程使用、打开的资源，如文件；</li><li>有关数据结构链接信息，使得进程可以加入到一些数据结构，如某些队列中。（Node成员变量） 。</li></ul></li></ul><h4 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h4><p>有不同的方式：</p><ul><li>链表：<strong>同一状态的进程其PCB连成一个链表，多个状态对应多个不同链表</strong>。也即各状态进程形成不同的链表，如就绪链表、阻塞链表。</li><li>索引表：<strong>统一状态的进程归入一个index表</strong>，其实就是数组。。。</li></ul><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>创建-&gt;运行-&gt;等待-&gt;唤醒-&gt;结束</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>引起创建有3个主要事件：</p><ul><li>系统初始化时（init）；</li><li>用户请求创建一个新进程；</li><li>正在运行的进程执行了创建进程的系统调用。</li></ul><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>内核选择一个就绪的进程，也即选择一个可以执行的进程，让它占用CPU而执行。（如何选择？）</p><h4 id="等待（阻塞）"><a href="#等待（阻塞）" class="headerlink" title="等待（阻塞）"></a>等待（阻塞）</h4><p>3个主要情况：</p><ul><li>请求并等待系统服务，无法马上完成；</li><li>启动某种操作，无法马上完成；</li><li>需要的数据没有到达；</li></ul><p>等待是进程对自己的阻塞，进程只能自己阻塞自己。</p><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>3个主要情况：</p><ul><li>等待进程需要的资源可被满足；</li><li>等待进程等待的事件到达；</li><li>将该进程的PCB插入到就绪队列。</li></ul><p>进程只能被别的进程或操作系统唤醒。</p><p>唤醒后的进程实际上进入就绪状态而不是运行状态。</p><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>4种主要情况：</p><ul><li>正常退出，自愿；</li><li>错误退出，自愿；</li><li>致命错误，强制；</li><li>被其他进程或操作系统杀死，强制。</li></ul><h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><ul><li><p>进程的三种基本状态：</p><ul><li>运行（Running）；</li><li>就绪（Ready）：该进程获得了除处理机外的一切所需资源，也即满足执行的所有条件；</li><li>等待（阻塞，Blocked）。</li></ul></li><li><p>其它状态：</p><ul><li>创建；</li><li>结束：正在结束。</li></ul></li></ul><h3 id="进程挂起（Suspend）"><a href="#进程挂起（Suspend）" class="headerlink" title="进程挂起（Suspend）"></a>进程挂起（Suspend）</h3><p>定义：进程没有占用内存空间，与进程阻塞不同。可能情况如，在虚拟内存管理中，该进程占用的所有内存空间的内容被暂时换出到硬盘中。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>挂起有两种：</p><ul><li>阻塞挂起：进程在外存等待某种事件的发生；</li><li>就绪挂起：进程在外存，但只要进入内存，就可以执行。</li></ul><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul><li><p>挂起：内存-&gt;外存</p><ul><li>阻塞-&gt;阻塞挂起；</li><li>就绪-&gt;就绪挂起；</li><li>运行-&gt;就绪挂起：对抢先式分时系统，当有高优先级事件执行，且内存空间不足时，系统可能把运行状态转到就绪挂起状态。</li></ul></li><li><p>外存中的状态转换：</p><ul><li>阻塞挂起-&gt;就绪挂起：当阻塞挂起需要的条件得到满足时，系统会把阻塞挂起状态转换成就绪挂起状态。</li></ul></li><li>解挂/激活：外存-&gt;内存<ul><li>就绪挂起-&gt;就绪：当没有就绪进程，或者，该进程的优先级高于就绪进程时，会进行这种转换；</li><li>阻塞挂起-&gt;阻塞：当内存足够时，会做这种转换。</li></ul></li></ul><h2 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h2><h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><ul><li>OS维护各种队列，以描述系统当前各种状态下的进程；</li><li>不同状态的PCB在不同的队列中；</li><li><p>当进程状态发生改变时，PCB在队列之间移动；</p></li><li><p>同个状态可能有多个队列，如根据优先级不同分多个就绪队列。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记三——虚拟内存</title>
      <link href="/2019/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%B8%89%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2019/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%B8%89%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记三——虚拟内存"><a href="#操作系统学习简记三——虚拟内存" class="headerlink" title="操作系统学习简记三——虚拟内存"></a>操作系统学习简记三——虚拟内存</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><ul><li><p>需要更大、更快、更便宜的存储器</p></li><li><p>存储器有很明显的层次结构，交由程序员管理太过复杂，由操作系统统一管理更加合理</p></li></ul><h3 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h3><ul><li>覆盖技术：程序员手动管理，只把需要的指令和数据放在内存中。</li><li>交换技术：自动管理，把暂时不运行的程序放到硬盘中，但需要多次倒换，开销不小。</li><li>虚拟存储技术：基于分段、分页</li></ul><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将逻辑按照自身逻辑，分为互相独立的若干个模块以及一个常驻模块。常驻模块负责装卸独立模块，模块在不同时间使用同一个内存区。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>程序员管理复杂</li><li>覆盖模块之间的频繁切换，其实是以时间换空间</li></ul><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>多个进程同时存在时，由操作系统进行管理，把等待状态的进程做转移，空出更多空间。一个重要特征是，交换的粒度是整个进程。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>交换时机：内存空间不够或者有不够的风险</li><li>交换区的大小</li><li>程序换入时的重定位：由于重新换入时，程序待的地址和原来很可能不同，会导致原先的地址失效，于是需要重定位，最好使用动态地址映射，也即建立新的页表，保证逻辑地址和原来相同，至于物理地址映射不同，完全没有影响。</li></ul><h3 id="与覆盖技术的区别"><a href="#与覆盖技术的区别" class="headerlink" title="与覆盖技术的区别"></a>与覆盖技术的区别</h3><ul><li>覆盖技术是一个程序中的各个模块之间，粒度较小，交换技术发生在整个内存空间中的各个进程之间，粒度较大。</li><li>覆盖技术需要程序员管理，交换技术由操作系统管理，对程序员透明。</li><li>覆盖技术是仅仅使用物理内存进行覆盖，而交换技术多使用了外存，如硬盘等，做交换中介。</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>实现内存和外存的交换，但实现基于分段或分页的交换，只对进程的部分内容做交换，以页或段为粒度大小。 </li><li>吸收交换技术的优点，可以由操作系统自动管理。</li></ul><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li>时间局部性：同一条指令或同一个数据的使用和下次使用集中在一个较短时间内，也就是说，同一个指令或数据的被访问之后，往往在较短时间内会有下一次访问。</li><li><p>空间局部性：当前指令/数据和临近的指令/数据，往往集中在一个较小的地址区域内。</p></li><li><p>局部性应用原理实例：</p><p>  1024个int值大小为4k，一般为一个页，参考一下两种访问二位数组的方法，假设只给了4k的内存大小。</p><ul><li><p>对第一种方式，每次访问二位数组，都产生缺页中断，则一共会产生<strong>1024*1024</strong>次缺页。</p></li><li><p>对第二种方式，只会产生<strong>1024</strong>次缺页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)&#123;</span><br><span class="line">        a[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; j++)&#123;</span><br><span class="line">        a[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="实现——虚拟页式内存管理"><a href="#实现——虚拟页式内存管理" class="headerlink" title="实现——虚拟页式内存管理"></a>实现——虚拟页式内存管理</h3><h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>分页机制详见上一篇文章，这里简述，CPU根据逻辑地址中的页号，从页表中查询出帧号。页表的索引是页号，而元素值是某些标记位加上帧号。标记位中包括一个是否存在的标记，0表示不存在该页号到物理地址的映射关系，1则存在。这个标记位在虚拟内存的具体实现中有重要作用。</p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul><li>用户程序在调入内存运行时，只加载入需要的页面，也即建立该页表时，先建立部分映射关系，而多余的映射关系不建立。</li><li>页调入：在运行过程中，如果发现要运行的程序或者要使用的数据不在内存中，则向系统发出缺页中断，此时系统再从外存中调入需要使用的内存页。</li><li>页换出：有多种页面置换算法，下文详述。</li></ul><blockquote><p>页表：页表表项为了适应虚拟页式内存管理的需要，需要设置一些标记位，例如</p><p>驻留位：表示该页在内存还是外存，如果该位为1，意味着存在该逻辑页到物理帧的映射关系。如果为0，会产生缺页中断。</p><p>保护位：表示允许对该页做什么类型的操作，该标记位不止一位，操作类型如只读、可读写、可执行等等。</p><p>修改位：表示该页在内存中是否被修改过。如果是1，意味着该页和外村中的数据不一致，所以在换出时需要更新外存中的数据。</p><p>访问位：该页在内存中是否被访问过，包括读和写。在页置换算法中使用。</p></blockquote><h4 id="缺页中断处理过程"><a href="#缺页中断处理过程" class="headerlink" title="缺页中断处理过程"></a>缺页中断处理过程</h4><ol><li>如果物理内存中有空闲空间，则分配一个物理页帧f，然后转第4步；否则转2；</li><li>采用某种页面置换算法，选择一个物理页帧f，查看其对应的页表项的标记位，判断是否被修改过，如果修改过，则将原物理页帧f写回外存；如果没有修改过，直接释放；</li><li>将原页帧f对应的页表项的驻留位改为0</li><li>将需要访问的页从外存中加载入f中，即写入或者替换f；</li><li>修改对应页表中的对应页表项，把帧号写为f，驻留位置为1；</li><li>重新执行被缺页中断的指令</li></ol><h4 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h4><ul><li>内存数据、指令</li><li>后备存储：硬盘中的数据、指令，在运行到需要时，由操作系统调入内存；</li><li>动态链接库：存在于硬盘中，操作系统需要调用的库，也是在运行需要时调入内存；</li><li>程序动态产生的数据：不属于上面几种，一般放在操作系统挂载的<strong>swap分区</strong>。</li></ul><blockquote><p>操作系统开辟的swap分区，并不是用来放程序和数据的，而是用来放程序在执行过程中动态产生的多余数据，这些数据原本位于内存中，需要在换出时即使用swap分区。</p></blockquote><h4 id="虚拟内存性能"><a href="#虚拟内存性能" class="headerlink" title="虚拟内存性能"></a>虚拟内存性能</h4><p>在应用虚拟内存的系统中，有效访问时间（effective memory access time，EAT）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EAT = 访问内存时间 × 页表命中几率 + page fault处理时间 × page fault几率</span><br></pre></td></tr></table></figure><p>而这其中，处理时间影响程度最大的因素是page fault处理时间，因为访问内存时间在对比page fault处理时间非常小，page fault处理时间包括磁盘访问时间等。</p><p>所以在优化访问时，可以利用降低page fault几率，即增加页表命中几率。</p><h3 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul><li>缺页中断，且内存已满时，选择哪个页面被置换。</li><li>尽量减少换入换出的次数;</li><li>页面锁定。常驻某些页面。可以使用锁定标记位。</li></ul><h4 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h4><h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>对每一个逻辑页面，计算其到下一次访问需要多长时间，置换时间最长的页面。 但实际上无法实现，因为操作系统无法计算每个页面的等待时间。 可用作评价标准，在模拟器上运行两次，第二次即可使用该算法。</p><h4 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h4><h5 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h5><p>选择驻留时间最长的。以一个链表维护纪录页面使用顺序，链表头就是驻留时间最长的。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>性能差</li><li>Belady现象。分配物理页帧越多，缺页率反而提高。FIFO的特征与置换的目的不同，所以其置换出去的页面有可能是要使用的。</li></ul><h4 id="最近最久未使用算法（LRU，Least-Recently-Used）"><a href="#最近最久未使用算法（LRU，Least-Recently-Used）" class="headerlink" title="最近最久未使用算法（LRU，Least Recently Used）"></a>最近最久未使用算法（LRU，Least Recently Used）</h4><h5 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h5><p>本质上是对FIFO进行动态调整。也是一种先进先出。 最久未使用。和最长驻留不一样。 基于局部性原理，有一定的合理性。</p><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><ul><li>维护访问顺序链表</li><li>维护访问顺序堆栈。这两种方法都需要更新数据结构，每次都要判断是否需要更新，如果需要，还要调整顺序。开销很大</li></ul><h4 id="时钟页面置换"><a href="#时钟页面置换" class="headerlink" title="时钟页面置换"></a>时钟页面置换</h4><p>对LRU的近似，对FIFO的改进。对LRU算法中顺序调整方式的优化。</p><h5 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h5><ul><li>使用页表项中的访问位（Access Bit，读写访问）。当页面装入时，初始化为0;被访问后，置为1;</li><li>页面组织环形链表，指针指向最先进来的页面。不需要调整链表顺序。</li><li>需要置换时，考察指针所指，若访问位为0，置换;若访问位为1，置0，移动指针到下一格，继续考察。</li><li>替换完成后，指针移动下一格。</li></ul><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>近似LRU，但不是以数据结构顺序来判断LR，而是以进入顺序和最近是否被访问的标记位来综合判断，其效果是对整个内存页面链表环形扫描判断，既对FIFO进行了访问顺序判断，又对LRU减少了维护数据结构的开销。 实质是一种折中。</p><h4 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h4><blockquote><p>Dirty Bit，被写后置1，即修改过。这个位标志着该页被替换出去时，是否要写回硬盘。如果对页执行读操作，Abit为1，Dbit为0;写操作，两个都为1。</p></blockquote><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>改进时钟置换，由只考虑Abit，但综合考虑Abit和Dbit。 如果二0，替换;一0一1，置二0;二1，Abit置0，Dbit置1。</p><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p>由于Dbit为1的页，换出时需要访问硬盘，而为0则直接释放，所以给执行过写操作的页两次机会，减少访问硬盘次数。</p><h4 id="最不常用法，LFU"><a href="#最不常用法，LFU" class="headerlink" title="最不常用法，LFU"></a>最不常用法，LFU</h4><h5 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h5><p>选择访问次数最少的页面</p><h4 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>一个进程当前正在使用的逻辑页面集合，可用一个二元函数W(t，A)表示。 t时当前时刻 A称为工作集窗口，即一个定长的页面访问时间窗口 W=在当前时刻t之前的A时间窗口中所有页面的组成的集合 W绝对值指工作集大小，也是页面数目。 <strong>工作集中的页面不一定实际存在于内存中，其描述的是一种需求</strong></p><h4 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>当前时刻进程实际驻留在内存中的页帧集合。</p><h4 id="页面置换过程中的问题"><a href="#页面置换过程中的问题" class="headerlink" title="页面置换过程中的问题"></a>页面置换过程中的问题</h4><p>应用进程在运行过程中，所需要的内存空间并不是固定的，如果可以动态调整，会增加利用率。</p><p>而要解决这个问题，可以在系统全局下对页进行调整，即使不同进程之间对内存使用存在竞争关系，以下两种算法可以实现这一需求。</p><h4 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h4><p>本质上是根据工作集的改变，对常驻集进行动态调整。</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><ul><li>缺页中断需要置换时，换出不在工作集窗口中的页</li><li>工作集窗口滑动时，换出掉出窗口的页</li></ul><h4 id="缺页率页置换算法"><a href="#缺页率页置换算法" class="headerlink" title="缺页率页置换算法"></a>缺页率页置换算法</h4><p>本质上是对工作集页置换算法的改进，改进对工作集调整的方式</p><blockquote><p>缺页率：缺页次数/内存访问次数 或 缺页平均间隔大小的倒数</p></blockquote><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>每两次缺页中断之间的时间间隔和一个阈值做比较，如果大，说明内存足够；如果小，说明分配的页不够；</p><ul><li>内存页面足够时，移除在两次中断之间的窗口中没有被引用的页；</li><li>内存页面不足时，正常添加缺失页。</li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记二——内存基础</title>
      <link href="/2019/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%BA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
      <url>/2019/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%BA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记二——内存基础"><a href="#操作系统学习简记二——内存基础" class="headerlink" title="操作系统学习简记二——内存基础"></a>操作系统学习简记二——内存基础</h1><h2 id="内存层次结构"><a href="#内存层次结构" class="headerlink" title="内存层次结构"></a>内存层次结构</h2><p>从上到下</p><ul><li>寄存器</li><li>Ln缓存</li><li>主存（物理内存）</li><li>硬盘（包括虚拟内存）</li></ul><h2 id="内存管理的目标"><a href="#内存管理的目标" class="headerlink" title="内存管理的目标"></a>内存管理的目标</h2><ul><li>抽象：简单的逻辑地址空间，相当于一个大数组</li><li>保护：隔离不同进程</li><li>共享：安全可靠有效的进程间数据交互</li><li>虚拟化：虚拟化出更多的内存空间</li></ul><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>物理地址空间：硬件</li><li>逻辑地址空间：应用程序拥有的内存范围</li><li>MMU：<strong>用于分页机制</strong>，位于CPU中，缓存了逻辑地址和物理地址的映射关系。完整的映射关系储存在内存中，MMU是为了加快CPU对逻辑地址和物理地址转换时的速度。</li></ul><h3 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h3><ul><li>编译：-&gt;.s文件，汇编语言</li><li>汇编：-&gt;.o文件，机器指令。把宏定义以及变量名等等转成一个段内的地址</li><li>链接：-&gt;.exe，将互相依赖的.o文件合成（比如调用某些库）。原本的地址需要再次转换成同一个段内的。</li><li>载入：将.exe文件加载进内存中，需要进行程序重定位。将.exe中的地址再次转换，成逻辑地址。</li></ul><h3 id="物理地址生成"><a href="#物理地址生成" class="headerlink" title="物理地址生成"></a>物理地址生成</h3><ul><li>取逻辑地址（指令中指定）</li><li>根据逻辑地址在MMU中查找对应的物理地址，如果查不到，去内存中查找。</li><li>根据物理地址跟主存请求对应内容，主存从总线把内容返还CPU。</li></ul><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><ul><li>外部碎片：没有分配给应用程序又无法使用的碎片地址空间</li><li>内部碎片：已经分配给应用程序但无法使用的碎片地址空间</li></ul><h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><ul><li><p>第一匹配分配（首次分配）：使用第一个能满足要求的内存空闲块</p><ul><li><p>对空闲块按地址排序</p></li><li><p>容易产生外部碎片</p></li></ul></li><li><p>最优匹配分配：找到最适合的，也即使用和需求大小差距最小的空闲块</p><ul><li><p>对空闲块按大小排序</p></li><li><p>可能出现很多微小外部碎片</p></li></ul></li><li><p>最差匹配分配：使用和需求大小差距最大的空闲块</p><ul><li>对空闲块按大小排序</li><li>容易破碎大的空闲块，导致大分区难以被分配</li></ul></li></ul><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><ul><li>压缩式：压缩、紧凑已使用的地址空间，把碎片空间往一个方向集中</li><li>交换式：使用swap硬盘空间</li></ul><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><ul><li>可分配的分区大小只能是2的某次方</li><li>需要的分区大小为2的某-1次方到2的某次方时，把整块分配给该进程</li></ul><p>这种处理方法可以减少碎片的空间</p><h4 id="实现（Buddy-system）"><a href="#实现（Buddy-system）" class="headerlink" title="实现（Buddy system）"></a>实现（Buddy system）</h4><h5 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h5><ul><li>由小到大找到最小的可用空间块；</li><li>如果空闲块过大，二分，直到大于其二分之一。</li></ul><h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><ul><li>把释放块放入空闲块数组；</li><li>合并：<ul><li>大小相同</li><li>地址相邻</li><li>低地址的块的起始地址必须是2的整数倍</li></ul></li></ul><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="为什么要有非连续内存分配"><a href="#为什么要有非连续内存分配" class="headerlink" title="为什么要有非连续内存分配"></a>为什么要有非连续内存分配</h3><ul><li>连续内存存在比较大的缺点<ul><li>利用率低</li><li>碎片多</li></ul></li><li>支持共享地址空间</li><li>支持动态加载</li></ul><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>现代操作系统使用比较少，80X86用的是这个</p><h4 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h4><p>根据应用程序使用的不同作用的地址段，把地址段分散到多个物理地址空间。如堆、栈、程序数据等等。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><p>使用段访问机制，用段地址和偏移地址进行寻址，具体实现有两种：</p><ul><li>使用段寄存器和偏移寄存器；</li><li>使用单地址，上部分是段地址，下部分是偏移地址</li></ul></li><li><p>具体实现方案：</p><ol><li>根据段号去段表（由操作系统初始化设置）中查到该段的首地址和长度</li><li>判断偏移地址是否在合理区间内（和长度对比）</li><li>偏移地址和段的首地址加起来得到物理地址</li></ol></li></ul><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>现代操作系统使用比较多</p><h4 id="想法-1"><a href="#想法-1" class="headerlink" title="想法"></a>想法</h4><p>划分物理内存至固定大小的<strong>帧</strong>（frame），划分逻辑地址空间到至和物理页帧相同大小的<strong>页</strong>（page）。</p><p>这里注意称呼，<strong>物理内存上称为帧，逻辑空间上称为页</strong>。</p><p>整体上和分段的想法类似，划分物理内存，但页帧大小固定。</p><h4 id="物理地址（页帧）的计算"><a href="#物理地址（页帧）的计算" class="headerlink" title="物理地址（页帧）的计算"></a>物理地址（页帧）的计算</h4><p>以单地址表示为例，前F位为帧号（f），后S位为偏移地址（o）。因此2^S表示的是一个帧的大小，因而有：</p><p><code>物理地址=2^S*f+o</code></p><h4 id="逻辑地址（页）的计算"><a href="#逻辑地址（页）的计算" class="headerlink" title="逻辑地址（页）的计算"></a>逻辑地址（页）的计算</h4><p>计算公式与页帧相同，而且偏移地址和其真实对应的物理地址的偏移地址相同。</p><p>不同的地方在于表示页号的位数和表示帧号的位数可以不同（帧大小和页大小相同），因为虚拟地址可以虚拟出比实际物理地址要大得多的空间。</p><h4 id="页寻址机制"><a href="#页寻址机制" class="headerlink" title="页寻址机制"></a>页寻址机制</h4><ol><li>根据<strong>页号</strong>在页表（由操作系统建立）中查到<strong>页帧号</strong></li><li>结合偏移地址（同一个），可计算出逻辑地址和物理地址。</li></ol><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p><strong>每个应用程序对应一个页表，建立专属的逻辑地址到物理地址的映射关系集。</strong></p><p>页表是一个大数组，其索引号是页号，对应的元素是某些标记位（可标记状态，如该页帧是否正在使用、页帧是否存在）和帧号的组合。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>访问一次内存单元要做2次内存访问<ul><li>一次访问页表，获取帧号</li><li>一次访问数据</li></ul></li><li>页表可能非常大</li><li>每个应用程序都有自己的页表</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>缓存</li><li>多级间接访问</li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>TLB，位于MMU中，也就是在CPU中，全称Translation Look-aside Buffer，缓存近期访问的页帧转换表项。</p><p>每次访问内存时，先使用TLB，如果命中，访问速度很快；如果没有命中，只能去查页表，但就把查到的表项更新到TLB中。</p><p><strong>TLB的命中率不会很低，因为在现代操作系统中，页大小一般是4K，这样就意味着4K的空间使用的是同一个页号/帧号，也即每4K个数据需要查一个新的页号，可以接受。同时，在程序设计时，尽量使程序具有局部性，增加TLB命中率。</strong></p><h5 id="分级间接访问——分级"><a href="#分级间接访问——分级" class="headerlink" title="分级间接访问——分级"></a>分级间接访问——分级</h5><ul><li><p>二级页表</p><p>  页号分为两个，p1和p2，以p1为索引（index）在一级页表中找到元素，该值为二级页表的起始地址，再加p2得到帧号。</p></li><li><p>多级页表类似</p></li><li><p>需要多次访问导致有时间上的损耗</p></li><li><p>空间上有很大的节省，上级页表记录的只是下级页表的首地址，如果映射关系存在，理论上来说还比不分级需要的空间更大，但有很多的映射关系是不存在的，就不需要下级页表，直接节省大段的空间。</p></li></ul><h5 id="分级间接访问——反向页表"><a href="#分级间接访问——反向页表" class="headerlink" title="分级间接访问——反向页表"></a>分级间接访问——反向页表</h5><p>分级页表仍然存在大地址问题，其占用空间直接由逻辑地址大小决定，反向页表要解决的是以物理地址大小决定页映射关系的存储。</p><p>目前cpu比较少使用反向页表</p><ul><li>主要思想：以页帧来索引页</li><li>基于页寄存器的方案<ul><li>使用一个页寄存器，与页表相反，即用帧号为索引，页号为元素</li><li>要实现的是以页号查帧号，非常麻烦</li></ul></li><li>基于关联内存的方案</li><li>基于hash查找的方案：以哈系计算，将页号映射到帧号。</li></ul><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>结合段式和页式</p><ul><li>在段式存储的基础上，给每个段加一级页表；</li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>每个进程对应一个段表，段表中的各种段，对应一个页表，页表再对应物理地址。</p><h4 id="进程内存共享"><a href="#进程内存共享" class="headerlink" title="进程内存共享"></a>进程内存共享</h4><p>基于段页式可以简便实现内存共享，可以开辟一个共享段，不同进程的共享段指向同一个页表。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统学习简记一——启动、系统调用、中断、异常</title>
      <link href="/2019/02/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%B8%80%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/02/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%AE%B0%E4%B8%80%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习简记一——启动、系统调用、中断、异常"><a href="#操作系统学习简记一——启动、系统调用、中断、异常" class="headerlink" title="操作系统学习简记一——启动、系统调用、中断、异常"></a>操作系统学习简记一——启动、系统调用、中断、异常</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><ol><li>BIOS程序被储存在闪存中，计算机加电后会自动从BIOS加载程序到<strong>一段固定的内存空间</strong>并执行。</li><li>BIOS启动后先进行硬件检测，然后去硬盘里找到Bootloader（Bootloader是负责启动真正的OS的程序），将其加载进<strong>一段固定的内存空间</strong>并执行。Bootloader一般放在硬盘的第一个主引导分区。</li><li>Bootloader找到OS在硬盘中的分区，并将OS加载入内存，然后将指令寄存器跳给OS所在的内存地址，也就是把操作权交出去。</li></ol><h3 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h3><ul><li>BIOS：固话到主板上的程序，完成最基础的功能<ul><li>只能引导固定的一个分区；</li><li>MBR：支持多分区、多磁盘，但数量有限制；</li><li>GPT：增加数量限制。</li></ul></li><li>UEFI：在所有平台上统一一致的操作系统启动服务。修改了如，对加载介质的可信性检查。</li></ul><h2 id="系统调用、中断、异常"><a href="#系统调用、中断、异常" class="headerlink" title="系统调用、中断、异常"></a>系统调用、中断、异常</h2><h3 id="概念和特征"><a href="#概念和特征" class="headerlink" title="概念和特征"></a>概念和特征</h3><p>操作系统负责做应用程序和硬件的中间层，这三个概念是操作系统分别与应用程序和硬件的打交道的方式，是跨越边界的行为。</p><ul><li><p>来源</p><ul><li>中断：外设。硬件和网络找操作系统。</li><li>异常：应用程序的错误</li><li>系统调用：正常的应用程序请求</li></ul></li><li><p>处理时间</p><ul><li>中断：异步</li><li>异常：同步</li><li>系统调用：异步或同步都有</li></ul></li><li>响应<ul><li>中断：是持续的，对应用程序是透明的。操作系统不想打断影响应用程序，而是默默处理，应用程序不会被动感知到中断。</li><li>异常：应用程序会有响应，如被杀死或者重复执行原指令。</li><li>系统调用：等待或者继续异步执行。</li></ul></li></ul><h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><ul><li><p>中断</p><ul><li><p>硬件：设置标记寄存器，并设置中断号，用来指定中断类型进而决定由哪段程序处理中断。</p></li><li><p>软件：</p><ol><li><p>保存当前的状态</p></li><li><p>根据中断号找到对应的中断程序，执行</p></li><li><p>清除中断标记</p></li><li><p>恢复保存的状态（所以不会打断原执行状态）</p></li></ol></li></ul></li><li><p>异常：错误指令有对应的异常编号</p><ol><li>保存现场</li><li>异常处理：杀死异常程序或重新执行异常指令（比如原先的条件不满足，重新尝试执行）</li><li>恢复现场</li></ol></li><li><p>系统调用：应用程序通过系统调用接口访问，也有进行编号</p><ul><li>涉及到用户态和内核态的特权级转换。内核态可以执行所有指令，用户态某些指令无法执行。</li><li>同个应用程序内的函数调用是同个堆栈的操作，而执行系统调用需要切换堆栈。</li></ul></li></ul><h3 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h3><ul><li><p>时间</p></li><li><p>空间</p><ul><li><p>建立编号与服务程序的映射关系</p></li><li><p>对现场保护的堆栈应用</p></li><li>验证参数的合法性（安全保障）</li><li>内核与应用程序之间的参数或执行结果的传递</li><li>内核独立地址空间</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的Linux安装之旅（二）——Arch安装</title>
      <link href="/2019/01/25/%E6%88%91%E7%9A%84Linux%E5%AE%89%E8%A3%85%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Arch%E5%AE%89%E8%A3%85/"/>
      <url>/2019/01/25/%E6%88%91%E7%9A%84Linux%E5%AE%89%E8%A3%85%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Arch%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="我的Linux安装之旅（二）——Arch安装"><a href="#我的Linux安装之旅（二）——Arch安装" class="headerlink" title="我的Linux安装之旅（二）——Arch安装"></a>我的Linux安装之旅（二）——Arch安装</h1><p>这里还是要特别感谢<a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">wd老哥的Arch安装教程</a>。</p><p>And，本文我只按照自己的安装路径写，具体其他问题，可以参考上面的安装教程</p><h3 id="启动盘制作"><a href="#启动盘制作" class="headerlink" title="启动盘制作"></a>启动盘制作</h3><p>在<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">ArchLinux官网</a>上下载<code>archlinux-**-x86_64.iso</code>这个文件，然后写入事先准备好的U盘。Linux下可以用WoeUSB，Windows下可以用Rufus。</p><h3 id="进入U盘下的Linux"><a href="#进入U盘下的Linux" class="headerlink" title="进入U盘下的Linux"></a>进入U盘下的Linux</h3><p>首先进入BIOS下设置好启动顺序，把USB调到第一位。后进入U盘中写入的系统，等待加载完毕。</p><h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><ul><li><p>有线网：如果路由器支持DHCP的话，可以插上网线后执行<code>dhcpcd</code>命令</p></li><li><p>无线网：最坑的地方来了，但这里还问题不大。执行：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p>看看能不能连上，如果可以，完美。如果不可以，若是联想笔记本，可以借鉴我。</p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill unblock all</span><br></pre></td></tr></table></figure><p>如果问题解决，ok。若还是不行，继续执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill list</span><br></pre></td></tr></table></figure><p>看看是否有模块<code>XX</code>(如联想有可能是<code>ideapad_laptop</code>)排在<code>Wireless LAN</code>前面，若是有，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe -r XX //按实际情况替换</span><br></pre></td></tr></table></figure><p>如果没有问题，重新尝试连接。</p><p><strong>连接后可以执行命令测试</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure><h3 id="分区工作"><a href="#分区工作" class="headerlink" title="分区工作"></a>分区工作</h3><p>首先执行命令查看分区情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>我们的目的是准备好一个容量大的挂载根目录<code>/</code>，准备一个500M到1G的挂载<code>boot</code>分区，也就是EFI分区。</p><p>Linux中对硬盘的表示是<code>/dev/sd?</code>或者<code>/dev/nvmen?</code>，而这个名字之后，再带p？的，就是这个磁盘第？分区。</p><h5 id="创建引导分区"><a href="#创建引导分区" class="headerlink" title="创建引导分区"></a>创建引导分区</h5><p><strong>引导分区不用和windows一样，windows10默认下的EFI引导分区才100M，我们自己建一个新分区。</strong></p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/nvmen0</span><br></pre></td></tr></table></figure><ul><li><p>输入m可以查看命令帮助。</p></li><li><p>如果是一个全新的硬盘，注意按<code>g</code>创建分区表。</p></li><li><code>n</code>创建分区，<code>t</code>更改分区类型，<code>l</code>可以查看支持的类型，根据类型输入，更改该分区类型为<code>EFI</code></li><li><code>w</code>别忘了，生效。</li><li>格式化<code>mkfs.fat -F32 /dev/nvmen?p?</code>，<code>nvmen?p?</code>是要作为引导分区的分区。</li></ul><h5 id="创建根目录"><a href="#创建根目录" class="headerlink" title="创建根目录"></a>创建根目录</h5><p>与创建引导分区大致一样，不一样的是不用更改类型，并且格式化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/nvmen?p?</span><br></pre></td></tr></table></figure><h5 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h5><p>这个每次从U盘引导进来的，都要做一次：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nvmen?p? /mnt</span><br><span class="line">mkdir /mnt/boot</span><br><span class="line">mount /dev/nvmen?p? /mnt/boot</span><br></pre></td></tr></table></figure><h3 id="换镜像源"><a href="#换镜像源" class="headerlink" title="换镜像源"></a>换镜像源</h3><p>编辑<code>/etc/pacman.d/mirrorlist</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>更换一个速度快的国内源到第一行，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server=http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><h3 id="安装基本包"><a href="#安装基本包" class="headerlink" title="安装基本包"></a>安装基本包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel</span><br></pre></td></tr></table></figure><p>等待安装完成</p><h3 id="配置自动挂载"><a href="#配置自动挂载" class="headerlink" title="配置自动挂载"></a>配置自动挂载</h3><p>这一步很重要，利用genfstab帮助每次启动时进行自动挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -L /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>执行完检查一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>结果看看是不是达到目的。</p><p>同时有个坑，就是如果改动了分区挂载点，比如改动了<code>boot</code>分区，就要重新回来这一步，把原来的结果删除掉，重新执行生成自动挂载配置。一般如果没有执行的话，进入硬盘引导出来会报错<code>emergency mode</code>相关。</p><h3 id="操纵权改变"><a href="#操纵权改变" class="headerlink" title="操纵权改变"></a>操纵权改变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localltime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S vim dialog wps_supplicant ntfs-3g networkmanager</span><br></pre></td></tr></table></figure><h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>把<code>zh_CN.UTF-8 UTF-8</code> <code>zh_HK.UTF-8 UTF-8</code> <code>zh_TW.UTF-8 UTF-8`</code>en_US.UTF-8 UTF-8`四行取消注释。然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure><p>编辑<code>/etc/locale.conf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.conf</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><p>编辑<code>/etc/hostname</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><p>在文件第一行输入你的主机名，以后这个就是你在Linux下工作时，本计算机的名字。如<code>mycomputer</code></p><p>编辑<code>/etc/hosts</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost</span><br><span class="line">127.0.1.1mycomputer.localdomainmycomputer</span><br></pre></td></tr></table></figure><h3 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><h3 id="IntelCPU安装Intel-ucode"><a href="#IntelCPU安装Intel-ucode" class="headerlink" title="IntelCPU安装Intel-ucode"></a>IntelCPU安装Intel-ucode</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode</span><br></pre></td></tr></table></figure><h3 id="安装Bootloader"><a href="#安装Bootloader" class="headerlink" title="安装Bootloader"></a>安装Bootloader</h3><p>最流行的是<code>Grub2</code></p><h5 id="安装os-prober"><a href="#安装os-prober" class="headerlink" title="安装os-prober"></a>安装os-prober</h5><p>它是用来帮助<code>grub</code>检测硬盘中存在的其他系统，如双系统时的windows。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S os-prober</span><br></pre></td></tr></table></figure><h5 id="安装配置grub引导"><a href="#安装配置grub引导" class="headerlink" title="安装配置grub引导"></a>安装配置grub引导</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br></pre></td></tr></table></figure><p>部署<code>grub</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub</span><br></pre></td></tr></table></figure><p>生成配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>这一步大概率出错。</p><ul><li><p>如果是<code>lvmetad/lvm</code>相关错误，或者是<code>WARNING: Device /dev/*xxx* not initialized in udev database even after waiting 10000000 microseconds</code>等等，应该</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit //退出arch-chroot</span><br><span class="line">mkdir /mnt/hostlvm</span><br><span class="line">mount --bind /run/lvm /mnt/hostlvm</span><br><span class="line">arch-chroot /mnt</span><br><span class="line">ln -s /hostlvm /run/lvm</span><br></pre></td></tr></table></figure><p>  再执行生成配置的命令，一般可以成功。</p><p>  <strong>需要注意的是，这一段如果是重启，重新进入，很可能要再执行一次</strong></p></li><li><p>如果没有扫到Linux的镜像，要先执行</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S linux</span><br></pre></td></tr></table></figure></li><li><p>如果没有扫到windows，可以忽略，等到不用U盘引导而是硬盘引导进入系统时，再执行一次生成配置。</p></li></ul><h5 id="安装后检查"><a href="#安装后检查" class="headerlink" title="安装后检查"></a>安装后检查</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>查查在文件中<code>menuentry</code>是不是有对应的系统引导信息。</p><h3 id="重启进入硬盘引导的系统"><a href="#重启进入硬盘引导的系统" class="headerlink" title="重启进入硬盘引导的系统"></a>重启进入硬盘引导的系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>如果grub部署问题不大，可以直接进入grub引导下的arch系统。</p><p>重启后记得，如果在U盘下没有部署其他系统的引导，重新执行一次grub生成配置的命令。</p><h3 id="创建交换文件"><a href="#创建交换文件" class="headerlink" title="创建交换文件"></a>创建交换文件</h3><p>交换文件是用于内存不足时缓存部分旧内容。</p><p>分配空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallocate -l 8G /swapfile</span><br></pre></td></tr></table></figure><p>大小看内存，足够大的情况下，可以4-8G。</p><p>更改权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /swapfile</span><br></pre></td></tr></table></figure><p>设置交换文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure><p>启用交换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure><p>设置交换文件分区的自动挂载，编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swapfile none swap defaults 0 0</span><br></pre></td></tr></table></figure><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p>在此之前都是<code>root</code>用户下，从此要创建新用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel username</span><br></pre></td></tr></table></figure><p><code>username</code>自行更改，就是用户名，<code>wheel</code>是组名，一般这么写就好了，不用改，后面会用到。</p><p>设置用户密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><h3 id="解决网络问题"><a href="#解决网络问题" class="headerlink" title="解决网络问题"></a>解决网络问题</h3><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p>如果无法连接，和上面相似，需要进行<code>rfkill unblcok all</code>的话，可以把它写成开机自动。如果还没有解决，仍然是<code>rfkill list</code>，如果有模块<code>XX</code>（这里使用我的情况<code>ideapad_laptop</code>），编辑<code>/etc/modprobe.d/ideapad_laptop.conf</code>：</p><p>在里面添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blacklist ideapad_laptop</span><br></pre></td></tr></table></figure><p>然后重启再试试。</p><p>如果还有问题，看看自己的无线网卡是不是realtek的，realtek无线网卡一生黑。</p><h3 id="配置sudo"><a href="#配置sudo" class="headerlink" title="配置sudo"></a>配置sudo</h3><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S sudo</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>找到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> %wheel ALL=(ALL)ALL</span></span><br></pre></td></tr></table></figure><p>去掉注释，然后重启系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="显卡驱动安装"><a href="#显卡驱动安装" class="headerlink" title="显卡驱动安装"></a>显卡驱动安装</h3><p>英特尔集显：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xf86-video-intel</span><br></pre></td></tr></table></figure><p>NVIDIA独显：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nvidia nvidia-utils lib32-nvidia-utils</span><br></pre></td></tr></table></figure><p><strong>独显安装完后，在桌面环境安装完之后，还要做一点配置，否则经常登录界面是黑屏</strong></p><h3 id="桌面环境Deepin"><a href="#桌面环境Deepin" class="headerlink" title="桌面环境Deepin"></a>桌面环境Deepin</h3><p>安装xorg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xorg</span><br></pre></td></tr></table></figure><p>安装deepin：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S deepin deepin-extra</span><br></pre></td></tr></table></figure><p>配置Deepin，编辑<code>/etc/lightdm/lightdm.conf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Seat:*]</span><br><span class="line">...</span><br><span class="line">greeter-session=lightdm-deepin-greeter</span><br></pre></td></tr></table></figure><h3 id="独显驱动完善"><a href="#独显驱动完善" class="headerlink" title="独显驱动完善"></a>独显驱动完善</h3><p>可以参考<a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus" target="_blank" rel="noopener">Archwiki对NVIDIA独显的配置文章</a>。</p><p>由于Deepin用Lightdm进行引导桌面启动，首先编辑<code>/etc/lightdm/display_setup.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">xrandr --setprovideroutputsource modesetting NVIDIA-0</span><br><span class="line">xrandr --auto</span><br></pre></td></tr></table></figure><p>给权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/lightdm/display_setup.sh</span><br></pre></td></tr></table></figure><p>编辑<code>/etc/lightdm/lightdm.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Seat:*]</span><br><span class="line">display-setup-script=/etc/lightdm/display_setup.sh</span><br></pre></td></tr></table></figure><p>启用lightdm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> lightdm</span><br></pre></td></tr></table></figure><p>如果用的是<code>SDDM</code>或者其他桌面管理，可以参考ArchWiki。</p><h3 id="网络问题完善"><a href="#网络问题完善" class="headerlink" title="网络问题完善"></a>网络问题完善</h3><p>桌面环境下用的是<code>NetworkManager</code>这个服务，一开始命令行用的是<code>netctl</code>，所以要做禁用和启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> netctl</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> NetworkManager</span><br></pre></td></tr></table></figure><h3 id="安装yay"><a href="#安装yay" class="headerlink" title="安装yay"></a>安装yay</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay.git</span><br><span class="line"><span class="built_in">cd</span> yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><h3 id="滚Arch"><a href="#滚Arch" class="headerlink" title="滚Arch"></a>滚Arch</h3><p>Arch不滚还有何乐趣？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Syu</span><br></pre></td></tr></table></figure><h3 id="墙墙"><a href="#墙墙" class="headerlink" title="墙墙"></a>墙墙</h3><p>个人觉得图形界面版的shadowsocks好用，不过这个萝卜青菜。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S shadowsocks-qt5</span><br></pre></td></tr></table></figure><p>之后打开<code>shadowsocks</code>，自己玩玩。</p><h3 id="Chrome代理"><a href="#Chrome代理" class="headerlink" title="Chrome代理"></a>Chrome代理</h3><p>先安装Chrome，可以用yay：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S google-chrome</span><br></pre></td></tr></table></figure><p>在代理下启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google-chrome-stable --proxy-server=<span class="string">"socks5://127.0.0.1:1080"</span></span><br></pre></td></tr></table></figure><p>这里的socks5有可能是http，这取决于shadowsocks里的设置。</p><p>然后安装<code>SwitchyOmega</code>这个插件。</p><h3 id="命令行代理"><a href="#命令行代理" class="headerlink" title="命令行代理"></a>命令行代理</h3><p>安装<code>proxychains-ng</code>，然后编辑<code>/etc/proxychains.conf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><p>这里的socks5也有可能是http，取决于shadowsocks里的设置。</p><h3 id="添加中国源"><a href="#添加中国源" class="headerlink" title="添加中国源"></a>添加中国源</h3><p>中国源ArchlinuxCN，很多中文软件如搜狗拼音，都在arch中国源中。编辑<code>/etc/pacman.conf</code>，在最后面加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Sy</span><br></pre></td></tr></table></figure><h3 id="中文字体"><a href="#中文字体" class="headerlink" title="中文字体"></a>中文字体</h3><p>刚刚安装完成的Arch中文是乱码的，可以参考<a href="https://wiki.archlinux.org/index.php/Fonts_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">ArchWiki中文字体</a>#%E4%B8%AD%E6%96%87%E5%AD%97)</p><p>安装自己喜欢的中文字体，然后更新字体缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-cache -vf</span><br></pre></td></tr></table></figure><p>这个字体是可以在图形界面里面设置的，也可以手动设置配置文件。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>安装<code>fcitx fcitx-im fcitx-configtoolfcitx-gtk2 fcitx-gtk3 fcitx-qt4 fcitx-qt5</code>，然后安装自己喜欢的输入法，如搜狗拼音<code>fcitx-sogoupinyin</code>。</p><p>然后启动fcitx-configtools，在里面按+号键，添加自己安装的输入法，就可以使用了。</p><h3 id="安装QQ、Tim、wechat"><a href="#安装QQ、Tim、wechat" class="headerlink" title="安装QQ、Tim、wechat"></a>安装QQ、Tim、wechat</h3><p>先启用multilib库，编辑<code>/etc/pacman.conf</code>，对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>这两行取消注释。然后执行<code>yay -Syy</code></p><p>安装Tim</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.qq.office</span><br></pre></td></tr></table></figure><p>qq</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.qq.im</span><br></pre></td></tr></table></figure><p>wechat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin-wechat</span><br></pre></td></tr></table></figure><h3 id="解决无法关机问题"><a href="#解决无法关机问题" class="headerlink" title="解决无法关机问题"></a>解决无法关机问题</h3><p>如果关机特别慢甚至无法关机，可以尝试编辑<code>/etc/systemd/system.conf</code>文件，将</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DefaultTimeoutStopSec=90s</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultTimeoutStopSec=10s</span><br></pre></td></tr></table></figure><h3 id="蓝牙安装"><a href="#蓝牙安装" class="headerlink" title="蓝牙安装"></a>蓝牙安装</h3><p>安装蓝牙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S bluez bluez-utils</span><br><span class="line">systemctl start bluetooth</span><br><span class="line">systemctl <span class="built_in">enable</span> bluetooth</span><br></pre></td></tr></table></figure><p>安装蓝牙音频</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S pulseaudio-bluetooth</span><br><span class="line">sudo vim /etc/pulse/system.pa</span><br></pre></td></tr></table></figure><p>配置蓝牙音频</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load-module module-bluetooth-policy</span><br><span class="line">load-module module-bluetooth-discover</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的Linux安装之旅（一）——扯淡</title>
      <link href="/2019/01/25/%E6%88%91%E7%9A%84Linux%E5%AE%89%E8%A3%85%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%89%AF%E6%B7%A1/"/>
      <url>/2019/01/25/%E6%88%91%E7%9A%84Linux%E5%AE%89%E8%A3%85%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%89%AF%E6%B7%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="我的Linux安装之旅（一）——扯淡"><a href="#我的Linux安装之旅（一）——扯淡" class="headerlink" title="我的Linux安装之旅（一）——扯淡"></a>我的Linux安装之旅（一）——扯淡</h1><p>​    说起我的Linux之旅，讲道理并不怎么愉快。。。四火对Linux很感兴趣，但在Linux安装使用这条路上踩了太多坑，甚至曾经对Linux产生了心里阴影了。</p><p>​    大一的时候总想试试，但限于知识水平有限，在安装时总会有很多愚蠢的做法，说起那时候甚至对最简单的概念，如挂载等，都没有理解其意义，可想而知会有很多愚蠢的做法。</p><p>​    大一暑假想要换电脑，那时候总在犹豫是否要换Mac，那时候我其实特别想换Mac，但又不甘于没有好好用过Linux，最终买了我现在在用的联想Y7000，然而就是这台电脑，让我痛苦地、错误地体会着Linux。</p><p>​    众所周知，Linux最难受的地方，在显卡和网卡，Y7000在这两块都碰到兼容性问题。。。真难过。而独显的问题还好解决，最难解决的是网卡（rtl8822be。嘤嘤嘤。Realtek网卡一生黑。</p><p>​    和很多人一样，刚开始我也选择了比较容易的ubuntu等发行版安装，但显卡和网卡的问题总是存在！！！甚至我的网卡问题，是偶然出现的，时灵时不灵，想好就好，不想好突然就挂。为了解决网络的问题，我把谷歌上所有关于rtl8822be网卡在Linux上的驱动问题的文章全都看了一遍，都没有解决。。。</p><p>​    从买了Y7000到大二上学期这一段时间，我好多次尝试装Linux，始终没有能完美解决问题。</p><p>​    到了近日，也就是大二这个寒假，我决定再来。因为有了一定的知识积累，在面对一些问题的时候，总不至于像以前那么懵逼，所以这我选择了装Arch。当然，最终我没有能够解决rtl8822be这个无线网卡的问题，我换了一个Intel的无线网卡，体验非常完美，开箱即用（realtek网卡一生黑）</p><p>​    想了想，还是要把安装过程中的一些问题记录下来，以便以后查阅。</p><p>​    这里特别感谢<a href="https://www.viseator.com/2017/05/17/arch_install/" target="_blank" rel="noopener">wd老哥的Arch安装教程</a>！！</p><p>​    PS：个人还想玩一玩Linux from scratch哈哈哈，玩好了也会记录下来的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>沉浸式状态栏简记</title>
      <link href="/2019/01/19/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
      <url>/2019/01/19/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="沉浸式状态栏"><a href="#沉浸式状态栏" class="headerlink" title="沉浸式状态栏"></a>沉浸式状态栏</h1><p>此经验只针对API21，即Android5.0以上的适配。</p><p>最关键的地方在于<code>style.xml</code>文件中的几个属性的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowLightStatusBar"</span> <span class="attr">tools:targetApi</span>=<span class="string">"m"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:statusBarColor"</span>&gt;</span>#00FFFFFF<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>statusBarColor：这个属性就是5.0加入的，把状态栏的颜色设置成透明的就好了。</li><li>windowTranslucentStatus：这个属性必须要true。</li><li>windowLightStatusBar：在没有设置这个属性的时候，<code>CoordinatorLayout</code>是全透明，其他Layout是半透明。。。</li></ul><p>至于fitsystemwindow这个属性，在我的华为上是可以不设置的。完全没有影响。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 沉浸式状态栏 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>两种IPC方式 Pipe vs eventfd</title>
      <link href="/2018/11/05/Pipe_vs_eventfd/"/>
      <url>/2018/11/05/Pipe_vs_eventfd/</url>
      
        <content type="html"><![CDATA[<h1 id="两种IPC方式-Pipe-vs-eventfd"><a href="#两种IPC方式-Pipe-vs-eventfd" class="headerlink" title="两种IPC方式 Pipe vs eventfd"></a>两种IPC方式 Pipe vs eventfd</h1><p>四火想专门对比这两种IPC方式的原因是，这些天在看Android的消息处理机制，书上的源码用的是老版本的Android，使用的IPC是管道，但最新版本的AOSP中，消息处理机制使用的IPC方式已经改为eventfd了。好奇心激发我去了解了一下，有必要记录下来。</p><h2 id="pipe管道"><a href="#pipe管道" class="headerlink" title="pipe管道"></a>pipe管道</h2><p>管道是最原始最基本的IPC机制，用于在进程之间完成数据传递。管道的特点非常鲜明：管道的数据传输是单向的，只能一端写一端读，所以它也采用了两个文件描述符引用，一个表示读端一个表示写端。</p><p>对管道进行读写实质上是对内核空间中的一片区域进行读写，管道是由内核管理的一个缓冲区，相当于我们放入内存中的一张纸，但这张纸读和写是完全分开的，管道的一端连接一个进程的输入，另一端连接一个进程的输出。</p><p>管道分两种，一种是无名管道，这种管道一般是存在与父子进程或者兄弟进程之间，在Linux系统中可以根据特殊的系统调用，创建一条单向连接的管道，联通父子进程或兄弟进程。还有一种是命名管道，即将管道抽象为文件存放于文件系统之中，等待进程通过该文件与管道建立连接。</p><h2 id="eventfd"><a href="#eventfd" class="headerlink" title="eventfd"></a>eventfd</h2><p>eventfd是Linux系统后来才引入的另一种轻量级的IPC方式，不同进程可以通过eventfd机制建立起一个共享的计数器，这个计数器由内核负责维护，充当了信息的角色，与它关联的进程可以对其进行读写，从而起到进程间通讯的目的。</p><h4 id="提供的方法："><a href="#提供的方法：" class="headerlink" title="提供的方法："></a>提供的方法：</h4><ul><li><p>eventfd：创建一个eventfd，返回一个文件描述符，通过该文件描述符可对eventfd进行读写操作。</p></li><li><p>read:读取计数器中的值：</p><ul><li>计数器中的值大于0，非初始状态<ul><li>设置了EFD_SEMAPHORE标志，返回1，且计数器中的值减1，这个模式是为跨进程做递减标记等而设计及的。</li><li>没有设置EFD_SEMAPHORE标志，返回计数器中的值，计数器清零</li></ul></li><li>计数器中的值等于0，说明没有人写入值，初始状态默认为0<ul><li>设置了EFD_NOBLOCK标志，返回-1，不阻塞。</li><li>没有设置EFD_NOBLOCK标记，阻塞直到计数器中的值大于0</li></ul></li></ul></li><li>write：向计数器写值，写入的值会和原先计数器中的值累加<ul><li>写入的值和原先计数器中的值的和小于0xFFFFFFFFFFFFFFFE，写入成功</li><li>否则<ul><li>设置了EFD_NONBLOCK标志，返回-1</li><li>没有设置，阻塞直到read</li></ul></li></ul></li><li>close关闭</li></ul><h3 id="对比Pipe和eventfd"><a href="#对比Pipe和eventfd" class="headerlink" title="对比Pipe和eventfd"></a>对比Pipe和eventfd</h3><p>eventfd是Linux在后版本中才提出来的一种IPC通讯方式，它更加轻量级，也更加灵活，它避免了pipe必须一端读一端写这个弊端，而且只创建了一个文件描述符，pipe必须创建读写两个文件描述符。eventfd的性能要比pipe要更好。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>pipe和eventfd都有一个非常巧妙的设计，就是可以与select、poll、epoll配合使用，以达到监听数据传输的目的。</p><p>这里以eventfd做讲解，eventfd本身并没有提供监听的功能，也就是说，计数器的数据被改变时，引用这个eventfd的进程并不会收到通知。但Linux在推出eventfd机制的时候，就已经设计好其可以和select、poll、epoll配合使用。这三个系统调用可以用来监听某个文件描述符（常指向的是一个socket，但这里是eventfd的计数器）中的数据，它们使用的时候需要传入一个封装的文件描述符用来指定监听目标，而eventfd创建时所返回的文件描述符正好可以传进其中。</p><p>eventfd经常会和epoll一起出现，在Android消息处理机制中，监听是否有消息传入用的机制就是eventfd+epoll。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> IPC </tag>
            
            <tag> Android消息处理机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux I/O简记</title>
      <link href="/2018/11/05/Linux_IO%E7%AE%80%E8%AE%B0/"/>
      <url>/2018/11/05/Linux_IO%E7%AE%80%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-I-O简记"><a href="#Linux-I-O简记" class="headerlink" title="Linux I/O简记"></a>Linux I/O简记</h1><h2 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h2><p>Linux默认的IO操作都是缓存IO，数据从源出发，不会被直接传送到目的，而是要经过内核，通过这种方式保证了内核对IO操作的可控。内核为IO提供了一个数据缓冲区，数据从源出发，先被拷贝到内核的缓冲区中，然后才从缓冲区拷贝到目的进程的用户地址空间。</p><h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><p>Linux为IO提供了5种方案：</p><ol><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ol><h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="1. 阻塞IO"></a>1. 阻塞IO</h3><p>Linux中，socket默认都是阻塞IO，用户进程通过系统调用，向内核索要数据read，内核会进行数据准备（比如网络IO中等待数据到达）。这个数据准备过程需要事件，而阻塞IO的特点就是在数据准备的过程中，用户进程会被阻塞，直到内核准备好了数据，才返回结果给用户进程，使用户进程唤醒。</p><h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="2. 非阻塞IO"></a>2. 非阻塞IO</h3><p>用户进程发出read，如果内核还没有准备好，会返回error，用户进程不需要等待，但是它取不到数据的可能性很大，需要不断地发出read请求，直到内核准备好了数据。</p><h3 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3. IO多路复用"></a>3. IO多路复用</h3><p>IO多路复用常见于select、poll、epoll。多路IO顾名思义同时进行多个IO，它的意义在于同时与多个Socket进行IO，只要监听列表中有一个或者多个socket有数据到来，用户进程就会被唤醒，通知处理。下面分别讲讲select、poll和epoll</p><h4 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1 select"></a>3.1 select</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select函数的主要逻辑是，传入要监听的文件描述符，用户进程需要将这些文件描述符fds拷贝给内核，而且这里文件描述符的数量是有限的，一般是被宏定义为1024，然后内核对fds指向的socket进行监听，挨个进行poll逻辑，检查是不是有可读事件，如果一个都没有，用户进程陷入阻塞。如果有事件到来，内核就会唤醒用户进程，接下来用户进程需要对每个socket尝试读取。</p><p>所以select有很大的缺点</p><ol><li>fds集合的大小只能是1024以下，太小了</li><li>fds需要从用于空间拷贝到内核空间，太麻烦了。</li><li>只要有一个fds是有数据可读的，所有socket都要被遍历一次，太惨了。</li></ol><h4 id="3-2-poll"><a href="#3-2-poll" class="headerlink" title="3.2 poll"></a>3.2 poll</h4><p>poll其实有点傻，poll只解决了1024问题，就是把监听的文件大小变大了，但没有解决第2、3个问题，这就意味着，监听的文件数量可以很大，但每次只要有一个事件到来，就要遍历所有的socket，这就很尴尬了，一旦大并发，不言而喻。</p><h4 id="3-3-epoll"><a href="#3-3-epoll" class="headerlink" title="3.3 epoll"></a>3.3 epoll</h4><p>select的第一个缺点很好解决，解决第二、三个缺点比较棘手，epoll采用了两个思想，一是添加中间层封装简化处理，二是分散事件处理，将高频、低频、不同事件分开处理，提高处理精确度。</p><h5 id="3-3-1-分散处理优化拷贝消耗"><a href="#3-3-1-分散处理优化拷贝消耗" class="headerlink" title="3.3.1 分散处理优化拷贝消耗"></a>3.3.1 分散处理优化拷贝消耗</h5><p>epoll将高频调用的唤醒/等待与低频调用的添加/删除/修改fd分开。唤醒、通知回调处理、等待这块的逻辑，epoll采用了内存映射，将内核空间中存储要返回给用户空间的数据的这块空间，映射到用户空间中，这样就避免了多次的内存拷贝，用户空间能直接访问到返回的数据。添加删除修改监听事件的逻辑，则是被分开进行处理，减少冗余的内存占用。</p><h5 id="3-3-2-中间层实线按需遍历"><a href="#3-3-2-中间层实线按需遍历" class="headerlink" title="3.3.2 中间层实线按需遍历"></a>3.3.2 中间层实线按需遍历</h5><p>epoll添加了中间层用来精确处理有数据返回的fds，只将有数据的fds暴露给用户进程，这样就避免了用户进程每次都要遍历所有监听的socket，极大地减少了内存占用。在select/poll中，用户进程会睡眠在一个包含其监听的所有socket的集合上，每次这个集合中有准备好的socket，就会唤醒该用户进程。而在epoll中，用户进程则是睡眠在epoll提供的中间层上，中间层再引入一个wait_entry_sk，与每个监听的socket一一对应，然后睡眠在socket集合上，每当集合中有事件来临，则通知wait_entry_sk，将它对应的socket放入中间层提供的ready_list中，然后唤醒用户进程去处理ready_list。</p><h3 id="4-信号驱动IO"><a href="#4-信号驱动IO" class="headerlink" title="4. 信号驱动IO"></a>4. 信号驱动IO</h3><p>信号驱动IO是一种半阻塞的IO，在准备数据阶段不阻塞，用户进程发送read后，直接返回。而等到数据准备完成之后，内核给用户空间发信号，通知用户进程阻塞，然后再将数据从内核空间复制到用户空间，这个过程是阻塞的。这种IO方式用得比较少。</p><h3 id="5-异步IO"><a href="#5-异步IO" class="headerlink" title="5. 异步IO"></a>5. 异步IO</h3><p>异步IO在整个IO过程中均不阻塞，用户进程发起read操作之后，立即返回，而内核接收请求之后，进行数据准备，并且在数据准备完成之后，将数据复制到用户进程空间，整个过程均不阻塞用户进程，完成之后再发送信号通知用户进程读取数据。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> I/O </tag>
            
            <tag> 多路复用 </tag>
            
            <tag> poll、epoll、select </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Zygote、System进程启动</title>
      <link href="/2018/10/19/Zygote%E3%80%81System%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/10/19/Zygote%E3%80%81System%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Zygote、System进程启动"><a href="#Zygote、System进程启动" class="headerlink" title="Zygote、System进程启动"></a>Zygote、System进程启动</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    Zygote，翻译为中文是“受精卵”，它是Android系统中，所有Java进程的父进程，负责创建新进程。System进程，是Android系统中系统服务运行所在的进程，它负责创建、管理所有的系统服务，包括AMS、PackageManagerServer等等十分重要的服务，都运行在System进程中。</p><p>​    Zygote和System进程的生命周期伴随整个系统，在系统启动时就会启动这两个进程，而直到系统关闭，它们才会被杀死。</p><p>​    值得一提的是，在Android5.0之后，Zygote进程在系统中一共存在两个，这主要是为了适应新增加的64位app而设计的，它们两个的主要功能其实是一致的。</p><p>​    And，System进程其实也是Zygote进程的子进程，它们启动的顺序大概可以描述为，Linux系统的初始化进程<code>&lt;init&gt;</code>通过读取脚本，创建Zygote，Zygote创建完成之后，先启动了System进程，然后自己再等待其他创建请求。</p><p>​    本文以API28的源码为基础进行分析。</p><hr><h2 id="Zygote启动过程"><a href="#Zygote启动过程" class="headerlink" title="Zygote启动过程"></a>Zygote启动过程</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><ol><li>init进程加载脚本，启动app_process文件中的main函数</li></ol><ol start="2"><li>创建虚拟机实例，进入ZygoteInit类的main方法中</li></ol><ol start="3"><li>创建一个Socket</li></ol><ol start="4"><li>fork出System进程</li></ol><ol start="5"><li>自己进入死循环中，不断从第3步创建的Socket中获取是否有创建进程的请求，并进行处理。</li></ol><hr><h3 id="Step1-app-main-main"><a href="#Step1-app-main-main" class="headerlink" title="Step1: app_main.main"></a>Step1: app_main.main</h3><p><strong>frameworks/base/cmds/app_process/app_main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走这个方法的目的是解析启动脚本中传进来的参数并真正调用方法启动进程。</p><ol><li>创建一个AppRuntime对象，是AndroidRuntime的子类，它的定义就在app_main文件中。</li></ol><ol start="2"><li>做一些解析工作，解析从启动脚本传过来的参数，这里要启动的是zygote进程，所以zygote变量为true。</li></ol><ol start="3"><li>调用runtime的start方法，runtime就是第一步创建的AppRuntime对象，但是它没有重写start方法，start方法是在它的父类AndroidRuntime中的。注意：传入的参数是ZygoteInit类的全名以及要传给这个类的参数，以及最后一个判断启动的是否是zygote进程的bool值。</li></ol><hr><h3 id="Step2-AndroidRuntime-start"><a href="#Step2-AndroidRuntime-start" class="headerlink" title="Step2: AndroidRuntime.start"></a>Step2: AndroidRuntime.start</h3><p><strong>frameworks/base/core/jni/AndroidRuntime.cpp</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">  ...</span><br><span class="line">  strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>, <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">    ...</span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>走这个方法的目的是从c++的世界转入Java的世界。</p><ol><li>初始化JNI</li></ol><ol start="2"><li>创建并开启一个虚拟机实例</li></ol><ol start="3"><li>给这个虚拟机注册JNI方法</li></ol><ol start="4"><li>各种解析之后，调用<code>env-&gt;CallStaticVoidMethod</code>方法，从而调起Java的方法，传入的三个参数分别是要调用的Java类、要调用的方法、传给方法的参数，这里要调用的Java类正是从上一步传进来ZygoteInit类的全称解析出来的，而<code>startMeth</code>参数是main方法，所以这里调用起来的是ZygoteInit的main方法。</li></ol><pre><code>**宣布进入Java的世界！**</code></pre><hr><h3 id="Step3-ZygoteInit-main"><a href="#Step3-ZygoteInit-main" class="headerlink" title="Step3: ZygoteInit.main"></a>Step3: ZygoteInit.main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">    String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">    String abiList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">            startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">            enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">            abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">            socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">        <span class="comment">// child (system_server) process.</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建ZygoteServer，然后做各种标记位的判断，比如<code>startSystemServer</code>判断是否要启动System进程，这里为true。</li></ol><ol start="2"><li>调用<code>zygoteServer.registerServerSocketFromEnv</code> (详见Step3.1)，创建一个Server端Socket，用来等待AMS请求，以创建应用程序进程。但这时候只是创建，还没开始等待。</li></ol><ol start="3"><li><code>forkSystemServer</code> (详见Step3.2) 创建一个新的子进程，这个新的子进程就是System进程，这里讨论的是Zygote的创建，这个方法会返回null，具体原因见Step3.2</li></ol><ol start="4"><li>调用<code>runSelectLoop</code>方法，在这个方法中无限等待请求。</li></ol><h4 id="Step3-1-ZygoteServer-registerServerSocketFromEnv"><a href="#Step3-1-ZygoteServer-registerServerSocketFromEnv" class="headerlink" title="Step3.1: ZygoteServer.registerServerSocketFromEnv"></a>Step3.1: ZygoteServer.registerServerSocketFromEnv</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerServerSocketFromEnv</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fileDesc;</span><br><span class="line">        ...</span><br><span class="line">        String env = System.getenv(fullSocketName);</span><br><span class="line">        fileDesc = Integer.parseInt(env);</span><br><span class="line">        ...</span><br><span class="line">        FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        ...</span><br><span class="line">        mServerSocket = <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Step3的第2步，创建并注册Socket。</p><p>通过socket的名字创建文件操作符，然后再通过文件操作符创建一个socket，其实这个socket在操作系统中的表现形式就是一个文件（这是关于Linux系统的知识，这里不详述）这个socket就存在成员变量<code>mServerSocket</code>中。</p><h4 id="Step3-2-ZygoteInit-forkSystemServer"><a href="#Step3-2-ZygoteInit-forkSystemServer" class="headerlink" title="Step3.2: ZygoteInit.forkSystemServer"></a>Step3.2: ZygoteInit.forkSystemServer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        String args[] = &#123;</span><br><span class="line">            <span class="string">"--setuid=1000"</span>,</span><br><span class="line">            <span class="string">"--setgid=1000"</span>,</span><br><span class="line">            <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010"</span>,</span><br><span class="line">            <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">            <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">            <span class="string">"--runtime-args"</span>,</span><br><span class="line">            <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">            <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.runtimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">                    </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Step3的第2步，它的目的是创建System进程</p><ol><li>首先是置顶了一些参数，这些参数主要是针对即将创建的子进程，即System进程的，可以看到这里为System进程设定了其UID、GID等等信息，而且指定了它的执行类是<code>com.android.server.SystemServe</code>r。</li></ol><ol start="2"><li>调用<code>Zygote.forkSystemServer</code>方法，这个方法会调用操作系统提供的fork方法，fork方法是Linux系统中创建一个新进程的方式，是一个非常特殊的方法，父进程执行fork方法之后，会出现两个几乎完全一样的进程，即原先的父进程和新建的子进程，同时返回fork方法，而且继续执行的代码是一致的，但是不同的是，fork的返回值不相同。在父进程中，会返回子进程的pid（ProcessID），而子进程中会返回0。</li></ol><ol start="3"><li>然后看接下来的代码，if语句判断pid是否为0，所以if语句块中的代码是子进程会执行的，而对于父进程，pid不为零，所以下面会返回null，这也就解释了Step3中为什么是返回null。读者看到这里可以重新返回去看看step3就会明白。（这种写法是非常典型的fork子进程之后的写法）</li></ol><ol start="4"><li>这里重新理一理Step3最后的步骤，在父进程，也就是Zygote进程中，<code>forkSystemServer</code>方法返回了null，于是会执行<code>runSelectLoop</code>方法，而子进程，也就是System进程，返回的是一个runnable，是由<code>forkSystemServer</code>方法中调用的<code>handleSystemServerProcess</code>方法返回的，它嵌套返回到main方法中后，会执行run方法，然后main方法就返回掉了，因为这是System进程了。</li></ol><h4 id="Step3-3-ZygoteServer-runSelectLoop"><a href="#Step3-3-ZygoteServer-runSelectLoop" class="headerlink" title="Step3.3: ZygoteServer.runSelectLoop"></a>Step3.3: ZygoteServer.runSelectLoop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">  </span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">        Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ZygoteConnection connection = peers.get(i);</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the child. We should always have a command to run at this</span></span><br><span class="line">                        <span class="comment">// stage if processOneCommand hasn't called "exec".</span></span><br><span class="line">                        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> command;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the server - we should never have any commands to run.</span></span><br><span class="line">                        <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// We don't know whether the remote side of the socket was closed or</span></span><br><span class="line">                        <span class="comment">// not until we attempt to read from it from processOneCommand. This shows up as</span></span><br><span class="line">                        <span class="comment">// a regular POLLIN event in our regular processing loop.</span></span><br><span class="line">                        <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                            connection.closeSocket();</span><br><span class="line">                            peers.remove(i);</span><br><span class="line">                            fds.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说到这里是Zygote进程死循环等待的地方，是Zygote进程fork出System进程之后，自己等待别的请求的地方。</p><ol><li>首先声明了两个数组，一个是文件描述符数组，第一个元素放的就是<code>mServerSocket</code>。另一个数组是<code>ZygoteConnection</code>数组，从类名就能猜出（当然事实也确实是这样滴）这个类描述的是一个和Zygote进程的连接，也就是说当Zygote接收到请求之后，会将它封装成一个ZygoteConnection对象。</li></ol><ol start="2"><li>开个死循环，调用方法<code>Os.poll</code>，处理轮询状态。poll也是Linux提供的系统调用，用于获知指定的Socket是否有事件到达。可以看到这里创建了一个<code>StructPollfd</code>数组，StructPollfd类是专门与Poll调用配合的一个类，用来描述poll调用的目的和结果，它既包含了一个描述poll监听目的的成员变量，也包含了一个描述已发生事件的成员变量。Poll调用根据传入的StructPollfd，指定监听的socket，指定监听的事件类型，如果没有事件到达，会阻塞在poll方法中，如果有事件到达，则将发生的事件写入StructPollfd对象中，然后返回。</li></ol><ol start="3"><li>可以看到，一开始装入的<code>pollfd</code>是<code>mServerSocket</code>，然后进入poll调用，一旦有事件到达，<code>poll</code>方法将跳出，进入下面的for循环，这时如果i=0，就是AMS请求与Zygote连接（注意这里并非请求创建进程），AMS一般在第一次请求创建进程时会先请求连接，之后如果没有关闭这个链接，则再请求创建之时不用请求连接。Zygote接收到连接请求，则将请求包装后，放入peers中，然后又回到Poll了。注意这里的连接，即<code>ZygoteConnection</code>对象，描述的是和AMS的连接，并不会包括AMS请求创建进程所传递的任何参数。</li></ol><ol start="4"><li>等到AMS再次请求创建时，取出peers中对应的连接，处理、调用<code>processOneCommand</code>方法。这个地方Poll的作用就是在于监听到socket有数据传入了，这些数据才是AMS请求创建进程所传递的数据，而读出这些数据的地方就在<code>processOneCommand</code>方法中。</li></ol><ol start="5"><li>往下又是一个非常典型的fork之后的写法，如果是子进程，就把processOneCommand的结果，即一个Runnable返回出去，在前面提到的ZygoteInit的main方法中会调用它run。父进程会判断是否和AMS已经断开了，通过方法<code>connection.isClosedByPeer()</code>判断的。如果已经断开，则把连接删除掉，如果没有断开，就继续在poll等待AMS请求创建进程。</li></ol><h4 id="Step3-4：ZygoteConnection-processOneCommand"><a href="#Step3-4：ZygoteConnection-processOneCommand" class="headerlink" title="Step3.4：ZygoteConnection.processOneCommand"></a>Step3.4：ZygoteConnection.processOneCommand</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">//从socket中读出要创建的进程的参数</span></span><br><span class="line">    args = readArgumentList();</span><br><span class="line">    ...</span><br><span class="line">    parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">    ...</span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal,parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote, parsedArgs.instructionSet, parsedArgs.appDataDir);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">    zygoteServer.setForkChild();</span><br><span class="line">        <span class="comment">// 子进程中要关掉ServerSocket</span></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.startChildZygote);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 父进程，即Zygote</span></span><br><span class="line">            handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法要处理创建进程的请求，在这里会fork出子进程了。</p><ol><li>调用<code>readArgumentList</code>方法，从<code>mServerSocket</code>中读出AMS放进去的请求参数，并封装一下</li></ol><ol start="2"><li>调用<code>Zygote.forkAndSpecialize</code>方法fork出子进程</li></ol><ol start="3"><li>父进程和子进程分开处理。这个地方涉及到的主要是应用程序进程的启动过程，这里不详述。</li></ol><p><strong><em>到这里Zygote就启动完成啦，在死循环里面等着。</em></strong></p><hr><h2 id="System启动"><a href="#System启动" class="headerlink" title="System启动"></a>System启动</h2><h3 id="Step1-ZygoteInit-handleSystemServerProcess"><a href="#Step1-ZygoteInit-handleSystemServerProcess" class="headerlink" title="Step1: ZygoteInit.handleSystemServerProcess"></a>Step1: ZygoteInit.handleSystemServerProcess</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">                Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Pass the remaining arguments to SystemServer.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这个方法在ZygoteInit里调用的，前面有说到。而且它的调用顺序是在Zygote的死循环开始之前的。</li></ol><ol start="2"><li>它的参数是前面设置好的一个参数，而且是指向子进程的，也就是system进程。其中<code>invokeWith</code>是没有设置的，应该是为了检测进程内存泄露等等Debug用途时才会有值，这一点如果有大大知道，望指点一二。</li></ol><ol start="3"><li>接下来调用<code>ZygoteInit.zygoteInit</code></li></ol><hr><h3 id="Step2-ZygoteInit-zygoteInit"><a href="#Step2-ZygoteInit-zygoteInit" class="headerlink" title="Step2: ZygoteInit.zygoteInit"></a>Step2: ZygoteInit.zygoteInit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>nativeZygoteInit</code>在System进程中启动了一个Binder线程池。这里不详述，关于Binder的知识后面会写文章。</li></ol><ol start="2"><li>调用了<code>RuntimeInit.applicationInit</code></li></ol><hr><h3 id="Step3-RuntimeInit-applicationInit"><a href="#Step3-RuntimeInit-applicationInit" class="headerlink" title="Step3: RuntimeInit.applicationInit"></a>Step3: RuntimeInit.applicationInit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用<code>findStaticMain</code></p><hr><h3 id="Step4-RuntimeInit-findStaticMain"><a href="#Step4-RuntimeInit-findStaticMain" class="headerlink" title="Step4: RuntimeInit.findStaticMain"></a>Step4: RuntimeInit.findStaticMain</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    ...</span><br><span class="line">    cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    ...</span><br><span class="line">    Method m;</span><br><span class="line">    ...</span><br><span class="line">    m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了className指向的类的main方法，也就是<code>SystemServer</code>类的main方法。包装了一下返回了一个<code>MethodAndArgsCaller</code>对象，这个类实现了Runnable接口，于是这个对象会一直返回一直返回到ZygoteInit方法中。</p><p>值得注意的是，这里返回到<code>ZygoteInit.main</code>方法中的进程，不是前面的Zygote进程，而是System进程，是由Zygote进程fork出来的。我们重新看看main方法中的那一段代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"><span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line"><span class="comment">// child (system_server) process.</span></span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">    r.run();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回出来的对象就是r，然后调用了r的run方法，然后把ZygoteInit的main方法返回掉，于是接下来就是<code>SystemServer.main</code>。</p><hr><h3 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main"></a>SystemServer.main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SystemServer().run();</span><br></pre></td></tr></table></figure><p>就调用了这么个方法</p><hr><h3 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer.run"></a>SystemServer.run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        String timezoneProperty =  SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timezone not set; setting to GMT."</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.timezone"</span>, <span class="string">"GMT"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!SystemProperties.get(<span class="string">"persist.sys.language"</span>).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.locale"</span>, languageTag);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.language"</span>, <span class="string">""</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.country"</span>, <span class="string">""</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.localevar"</span>, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Initialize the system context.</span></span><br><span class="line">        createSystemContext();</span><br><span class="line">        <span class="comment">// Create the system service manager.</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext</span><br><span class="line">        ...</span><br><span class="line">        SystemServerInitThreadPool.get();</span><br><span class="line">        );</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startCoreServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是真正运行System进程要初始化的工作的地方！！！</p><ol><li>先设置了一些时区、语言等等</li></ol><ol start="2"><li>创建了一个消息循环Looper</li></ol><ol start="3"><li>创建系统上下文、创建SystemServiceManager,创建一个线程池用来维护系统服务。</li></ol><ol start="4"><li><p>调用各个方法启动各种系统服务，关于系统服务。</p><ul><li><p><code>startBootstrapServices</code>：这里启动一些依赖性比较强的服务。如安装器、设备标识服务、AMS、PackageManagerServices、UserManagerService、电池管理服务、Recovery服务、亮度服务、传感器等等等等。</p></li><li><p><code>startCoreServices</code>：这里启动了UsageStatsService（用户使用情况服务）、WebViewUpdate服务</p></li><li><p><code>startOtherServices</code>：一些杂七杂八的服务，比如闹钟、蓝牙、网络（包括wifi）、媒体、存储等等甚至是statusBar也是单开一个服务的，还有一个重要的是WindowymanagerServices，他在这里的原因是它要等到传感器都初始化好之后，它才能启动，这里顺便一提，还给AMS设置了一个回调systemReady，告诉AMS可以运行非系统的代码了。以及NotificationManager也是在这里创建的。</p></li></ul></li></ol><ol start="5"><li>启动Looper</li></ol><p><strong>到这里System进程就启动完成啦。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android系统 </tag>
            
            <tag> Zygote </tag>
            
            <tag> System </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四火的置顶</title>
      <link href="/2018/10/19/%E5%9B%9B%E7%81%AB%E7%9A%84%E7%BD%AE%E9%A1%B6/"/>
      <url>/2018/10/19/%E5%9B%9B%E7%81%AB%E7%9A%84%E7%BD%AE%E9%A1%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="四火的置顶"><a href="#四火的置顶" class="headerlink" title="四火的置顶"></a>四火的置顶</h1><p>我叫陈钊燚，是华中科技大学软件学院的一名小学生，也是华中科技大学软件学院科创团队和启明学院联创团队Android组的一名小学生。现在主要做一些安卓开发、研究的事情。从大学入学就有开博客的想法，只是困于一开始水平不高，不敢丢人现眼，于是努力学习，这些天有了一些小想法和小总结，感觉有必要正式地记录下来，于是开了这个博客。</p><hr><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ul><li>Android开发记录</li><li>Android源码学习：主要以最新的API28为分析对象，如有不同版本，会在博文开头说明。</li><li>计算机知识记录，包括一些课程中、自学中的感受。</li><li>其他杂七杂八</li></ul><hr><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>此博客主要用于学习交流使用，不涉及任何政治、商业内容，文章总会借鉴一些前辈大佬，但绝不是照抄照搬，记录的都是个人的学习感受。但如果有原作者认为本人有侵犯版权的行为，请发邮件通知我，一定按理处理。</p><p>还有，感谢Android届的几位大大们，特别是罗升阳大大、gityuan大大、郭霖大大，我正是从他们的书和博客中窥探到了Android世界的一二分，特别感谢。</p><p><strong>And 小学生谢谢点开博客的各位，欢迎所有人的评价、建议以及批评。共勉</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 置顶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跳出小世界</title>
      <link href="/2018/10/19/%E8%B7%B3%E5%87%BA%E5%B0%8F%E4%B8%96%E7%95%8C/"/>
      <url>/2018/10/19/%E8%B7%B3%E5%87%BA%E5%B0%8F%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="VPS梯子架设教程"><a href="#VPS梯子架设教程" class="headerlink" title="VPS梯子架设教程"></a>VPS梯子架设教程</h1><p>程序员入门必修课，番羽土啬hhhh。这篇教程教你从0搭梯子</p><p>需要用到的工具和平台有：<del>钱</del>、VPS主机、shadowsocks</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><hr><p>简单讲讲关于墙的原理。我们进行网络访问时，将域名，比如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 通过一层层发向更高级的主机，进行解析成为IP地址（类似127.0.0.1这样的格式），再根据IP发送到真正需要发送的服务器，由服务器返回你需要的数据。</p><p>而提供上层网络服务的节点（ISP）是可以控制的，在CN范围内的网络，都受到GFW的控制，GFW是The Great Fire Wall of China的简写，意指“中国网络防火墙”(字面意为“中国防火长城”)，这是对“国家公共网络监控系统”的俗称，国内简称“国家防火墙”。是用于抵御国外非法、不健康、不合时宜的网站的网络审查机制。境外网站（包括国内的人在境外租用空间开设的网站）一旦被列入黑名单，中国大陆任何地方均不能访问到它。 </p><p>比如google、youtube这样的网站，便是列于GFW的黑名单之中，GFW使用了多种技术对网络请求进行监听和拦截，比如关键字过滤、IP地址封锁、DNS劫持污染等等。这些技术的原理这里就不再详述，简而言之，如果一个请求的目标在黑名单之中，那么这个请求将会被拦截、阻断。</p><p>而想要访问黑名单中的网络，就必须绕开GFW，shadowsocks就是这样一个工具。它对网络请求的发送进行加密，使得数据经过GFW时，无法识别数据的内容，那么GFW会放过这个数据。但有个问题，就是请求是发送出去了，可是返回呢？直接返回的数据还是会被 GFW拦截，所以需要一个部署在国外网站的服务器，它可以直接访问国外网站，我们不是直接请求，而是将请求发送到该服务器，由它代转发这次请求，并将返回的数据由shadowsocks服务端进行加密后，再返回，这样就实现了绕过GFW的目的。</p><p>而还有一种现在没有被GFW墙掉的情况，就是你的网络支持ipv6访问。我们所熟悉的IP地址，多是类似127.0.0.1这样的格式，这种格式是ipv4协议指定的，而在网络高速发展的今天，ipv4地址的总数量出现了不够用的趋势，于是ipv6出现了，ipv6的格式类似ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，而且使用了与ipv4不同的转发技术，而目前GFW还没能对使用ipv6访问的请求进行拦截。所以如果你的网络和主机都支持ipv6，那么你可以直接访问到google。但ipv6目前普及程度不高，主要在国内某些高校的校园网中有应用（例如hust的宿舍区嘻嘻嘻</p><h2 id="VPS服务器"><a href="#VPS服务器" class="headerlink" title="VPS服务器"></a>VPS服务器</h2><p>部署shadowsocks的服务器需要连接在没有墙的国外网络中，这里几个推荐：搬瓦工、vultr。这两个是我个人用过的服务器，体验良好，连接稳定。价格的话，搬瓦工最便宜的价格是一年19.99刀，而vultr最便宜的有一个月2.5刀，但是这个服务是ipv6 only，就是只有ipv6能访问这个主机（我们就是为了能访问国外网站，有ipv6我还要你何用）所以最便宜能用的为一个月3.5刀。</p><p>​    图看这里。这个是vulr的<br><a href="https://i.loli.net/2018/09/22/5ba6387bb5f52.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba6387bb5f52.png" alt></a><br>这个是搬瓦工的。<br><a href="https://i.loli.net/2018/09/22/5ba6389c78ca8.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba6389c78ca8.png" alt></a><br>我们可以观察以下，对两个最便宜的套餐，vultr稍贵一点，但它的硬盘容量是20G，这点如果对于只想使用shadowsocks的大噶其实不重要，但是如果你还想在这台服务器上部署网站，如个人博客之类的，那硬盘容量还是比较重要的。所以看个人需（qian）求（bao）啦。</p><p>购买服务器的时候需要选择操作系统，对于操作系统选择，这里我提个建议，不用选择最新的发布版本。因为网上对于各种坑的教程，对于新版本往往没那么齐全，很多在新版本中才会出现的坑经常查不到，这会耗费很多不必要的时间。个人建议可以选用centOS 6。我这里也是使用这个版本做例子。</p><hr><h2 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h2><h4 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h4><p>有了一个服务器了，接下来要进行shadowsocks服务端的部署。首先要连上服务器。这里我们使用的软件叫xshell（<a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">https://xshell.en.softonic.com/</a> ）安装都按默认即可。打开xshell</p><ul><li><p>这里是我的两个服务器。新安装时应该时没有的。点击“新建”<br><a href="https://i.loli.net/2018/09/22/5ba63e999894f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63e999894f.png" alt></a></p></li><li><p>注意画出来的这几个地方，都是需要填写的。首先是主机和端口号。打开你购买的主机的网站（这里我用搬瓦工做例子）登录后点击Services下的my service，再点击KiwiVM Control Panel<br><a href="https://i.loli.net/2018/09/22/5ba63eba300f9.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63eba300f9.png" alt></a></p></li><li><p>第一次点进来似乎会有初始化界面（当时没留图，不记得了），可以查看到你的密码和端口，这时候就可以记下来，后面会用。</p></li><li><p>在这个页面可以管理控制你的服务器。在这里可以看到你的服务器的信息，可以开关服务器，可以为你的服务器改变系统（点击stop，再左侧Install new OS，选择并确定，稍等几分钟就可以更换你的系统）<br><a href="https://i.loli.net/2018/09/22/5ba63ede4f038.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63ede4f038.png" alt></a></p></li><li><p>可以观察到，这是我的主机，右侧的IP address就是你的IP，SSH Port是你的端口号，把这两个号填入xshell的新建页面中。点击连接。弹出来用户名页面，填入root点击确定（Linux默认root用户是超级用户）<br><a href="https://i.loli.net/2018/09/22/5ba63eff0c81b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63eff0c81b.png" alt></a></p></li></ul><p><a href="https://i.loli.net/2018/09/22/5ba63f44bdb81.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba63f44bdb81.png" alt></a></p><ul><li><p>密码？如果初始化的时候有记下来的，可以直接填入，如果没有的，先在Main controls中点击stop，然后点击左侧Root password modification，点击Generate，就可以重置你的密码，它会弹出来一个密码，是一串很蛋疼的序列（在这里不能改，拍个照下来吧）等待主机重启<br><a href="https://i.loli.net/2018/09/22/5ba640202c751.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba640202c751.png" alt></a></p></li><li><p>然后重新打开你的xshell。填入密码登录确定。<br><a href="https://i.loli.net/2018/09/22/5ba640aa1cfb6.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/22/5ba640aa1cfb6.png" alt></a></p></li><li><p>弹出来这样的字符就说明正确了。这就已经连接上你的服务器了。<br>接下来敲入命令并回车</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure></li><li><p>再输入你自己的新密码并确认一遍密码，之后你的root用户的密码就是这个啦。如果有遗忘了的，可以重新去页面那边重置。</p></li></ul><h4 id="安装Vim"><a href="#安装Vim" class="headerlink" title="安装Vim"></a>安装Vim</h4><p>vim是Linux下很常用的命令行文本编辑器，下面有一些配置文件编辑时需要使用到vim，如果系统内没有vim，首先要安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure><p>vim的用法很多，这里简单说明最基本使用：</p><blockquote><p>​    每次进入时是命令模式，此时是无法输入的，按a或i进入编辑模式<br>编辑内容后，按ESC键返回命令模式<br>​    在命令模式下输入引号“：”可以看到下方会打出一个引号<br>​    输入wq后按回车键保存并退出，如果不想保存，可以直接输入q!后按回车键</p></blockquote><h4 id="安装Pip"><a href="#安装Pip" class="headerlink" title="安装Pip"></a>安装Pip</h4><p>下面要干的事就是安装pip,这是一个Python的包管理工具，我们通过它来下载安装shadowsocks。<br>由于Pip所在的包不在默认的源里，而在EPEL源里，所有首先安装EPEL源，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br></pre></td></tr></table></figure><p>由于CentOS中有一些源被默认禁用，需要先启用EPEL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/epel.repo</span><br></pre></td></tr></table></figure><p>将下面的第一个和第三个的<code>enable=0</code>改成<code>enable=1</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[epel]</span><br><span class="line">  name=Extra Packages for Enterprise Linux 6 - $basearch</span><br><span class="line"><span class="meta"> #</span><span class="bash">baseurl=http://download.fedoraproject.org/pub/epel/6/<span class="variable">$basearch</span></span></span><br><span class="line">  mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-6&amp;arch=$base  arch</span><br><span class="line">  failovermethod=priority</span><br><span class="line">  enabled=0</span><br><span class="line">  gpgcheck=1</span><br><span class="line">  gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</span><br><span class="line">[epel-debuginfo]</span><br><span class="line"> name=Extra Packages for Enterprise Linux 6 - $basearch - Debug</span><br><span class="line"><span class="meta"> #</span><span class="bash">baseurl=http://download.fedoraproject.org/pub/epel/6/<span class="variable">$basearch</span>/debug</span></span><br><span class="line"> mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-6&amp;arch  =$basearch</span><br><span class="line"> failovermethod=priority</span><br><span class="line"> enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</span><br><span class="line"> gpgcheck=1</span><br><span class="line">[epel-source]</span><br><span class="line"> name=Extra Packages for Enterprise Linux 6 - $basearch - Source</span><br><span class="line"><span class="meta">#</span><span class="bash">baseurl=http://download.fedoraproject.org/pub/epel/6/SRPMS</span></span><br><span class="line"> mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-6&amp;arc  h=$basearch</span><br><span class="line"> failovermethod=priority</span><br><span class="line"> enabled=0</span><br><span class="line"> gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</span><br><span class="line"> gpgcheck=1</span><br></pre></td></tr></table></figure><p>安装Pip：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install python-pip</span><br></pre></td></tr></table></figure><p>这里说另一个安装方法，也可以一试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure><h4 id="更新pip源"><a href="#更新pip源" class="headerlink" title="更新pip源"></a>更新pip源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><h4 id="安装依赖模块"><a href="#安装依赖模块" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install python-setuptools m2crypto supervisor</span><br></pre></td></tr></table></figure><p>此时如果出现ImportError: cannot import name main的错误，就先用reboot命令重启下机器，之后再重新执行<code>pip install setuptools</code>。</p><h4 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;服务器ip&quot;,</span><br><span class="line">    &quot;server_port&quot;:自己指定一个端口号,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;自己指定一个密码&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>温馨提示，一定要注意有没有双引号和逗号！！！</strong><br>或者如果你想要开通多个用户的话，也可以这么输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;服务器ip&quot;,</span><br><span class="line">&quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">&quot;local_port&quot;:1080,</span><br><span class="line">&quot;port_password&quot;:&#123;</span><br><span class="line">&quot;端口1&quot;:&quot;password0&quot;,</span><br><span class="line">&quot;端口2&quot;:&quot;password1&quot;,</span><br><span class="line">&quot;端口3&quot;:&quot;password2&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;timeout&quot;:300,</span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按ESC : wq 回车 保存</p><p>赋予配置文件执行的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><h4 id="运行shadowsocks服务"><a href="#运行shadowsocks服务" class="headerlink" title="运行shadowsocks服务"></a>运行shadowsocks服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure><h4 id="配置开机自启"><a href="#配置开机自启" class="headerlink" title="配置开机自启"></a>配置开机自启</h4><ul><li>先查一查ssserver在哪里<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis ssserver</span><br></pre></td></tr></table></figure></li></ul><p>如果上面的安装都是正确的，会出现ssserver所在的路径<br><a href="https://i.loli.net/2018/09/23/5ba70494069d1.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/23/5ba70494069d1.png" alt></a></p><ul><li>接下来实现开机自启<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></table></figure></li></ul><p>在文件末尾添加<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line"><span class="meta">#</span><span class="bash"> ssserver路径换成你自己的路径</span></span><br></pre></td></tr></table></figure></p><p>保存退出</p><p>到这里就已经完成了服务端的配置。接下来是客户端。</p><hr><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><h4 id="Windows版本"><a href="#Windows版本" class="headerlink" title="Windows版本"></a>Windows版本</h4><ul><li>打开Github，搜索shadowsocks-windows,点击打开shadowsocks/shadowsocks-windows<br><a href="https://i.loli.net/2018/09/23/5ba705ca42a30.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/23/5ba705ca42a30.png" alt></a></li><li>点击releases，就是我这里显示的40 releases那个地方<br><a href="https://i.loli.net/2018/09/23/5ba7060c3b23f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/23/5ba7060c3b23f.png" alt></a><br>这里会有很多版本，选择其中一个的.zip下载，解压缩即可使用，如果你发现下载的这个版本不能用，有可能是兼容的问题，换一个版本试试</li><li>打开shadowsocks，在这里输入服务器地址、服务器端口、密码、加密方式，这些都是刚刚在服务端配置文件里面配置的。之后点击确定即可。<br><a href="https://i.loli.net/2018/09/23/5ba70692a672f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/23/5ba70692a672f.png" alt></a></li><li>测试一下，在浏览器里输入<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 如果成功打开google的话，你就成功啦。<br>客户端这边也有一些可以配置的，windows在右下角可以右键点击那个小飞机，系统代理模式可以更改，PAC模式和全局模式，这个不详述了。<h4 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h4></li><li>一样是在github上搜索shadowsocks，不过要使用shadowsocks-qt5，有一个AppImage，可以使用<h4 id="Android版本"><a href="#Android版本" class="headerlink" title="Android版本"></a>Android版本</h4></li><li>github上搜索，使用shadowsocks-android版本，这个本人亲测有兼容性问题，多试几个版本，找到能兼容你的手机的<h4 id="iOS版本"><a href="#iOS版本" class="headerlink" title="iOS版本"></a>iOS版本</h4></li><li>iOS的shadowsocks在国内区的Appstore找不到，笔者找了特别久，找到两款替代的，SkipWorld和SsrConnection，这两款软件都可以和shadowsocks客户端作用一样。</li></ul><hr><p>网上还有很多关于shadowsocks优化的教程，包括用锐速、BBr等等，这里不想详述，有兴趣可以去找找看。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shadowsocks </tag>
            
            <tag> 翻墙 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
